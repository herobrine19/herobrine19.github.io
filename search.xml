<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[785.判断二分图]]></title>
    <url>%2F2020%2F07%2F16%2F785-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[题目链接785.判断二分图 题目描述给定一个无向图graph，当这个图为二分图时返回true。 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。 graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。 12345678910示例 1:输入: [[1,3], [0,2], [1,3], [0,2]]输出: true解释: 无向图如下:0----1| || |3----2我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。 12345678910示例 2:输入: [[1,2,3], [0,2], [0,1,3], [0,2]]输出: false解释: 无向图如下:0----1| \ || \ |3----2我们不能将节点分割成两个独立的子集。 注意: graph 的长度范围为 [1, 100]。 graph[i] 中的元素的范围为 [0, graph.length - 1]。 graph[i] 不会包含 i 或者有重复的值。 图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。 解题思路什么是二分图二分图也叫二部图。对于图中的任意两个节点u和v，如果他们之间有一条边相连，那么u和v必须属于不同的集合。并且只能有两个集合，如果两个相连的点在同一个集合，就不是二分图。 如何判断二分图判断这个图是否是二分图，我们可以对其节点进行染色操作，最后根据染色的结果来判断是否是二分图。 我们可以任选一个节点开始，将起染成红色，然后遍历与其相连的节点，把他们都染成绿色，再把和这些绿色节点相邻的点染成红色，以此类推，直到所有的节点都被染色。 如果我们染色成功，则红色节点和绿色节点分属两个集合，这个无向图就是个二分图；如果我们不能成功染色，就是说在染色过程中遇到了一个已经染色的节点，假设它是红色的，但我们现在要把它染成绿色，这就发生了矛盾，就无法继续染色了，说明这个图就不是二分图。 算法流程 任选一个节点，将其染成红色，并从该节点开始对整个无向图进行遍历； 在遍历的过程中，如果我们通过节点 u 遍历到了节点 v（即 u 和 v 在图中有一条边直接相连），那么会有两种情况： 如果 v 未被染色，那么我们将其染成与 u 不同的颜色，并对 v 直接相连的节点进行遍历； 如果 v 被染色，并且颜色与 u 相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回 False作为答案。 当遍历结束时，说明给定的无向图是二分图，返回 True 作为答案； 可以使用DFS或者BFS对无向图进行遍历。 注意题目中给定的无向图不一定保证连通，因此我们需要进行多次遍历，直到每一个节点都被染色，或确定答案为False 为止。每次遍历开始时，我们任选一个未被染色的节点，将所有与该节点直接或间接相连的节点进行染色。 代码dfs123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;private: static constexpr int UNCOLORED = 0; static constexpr int RED = 1; static constexpr int GREEN = 2; vector&lt;int&gt; color; //记录节点涂色的情况 bool flag; //记录是否是二分图public: void dfs(int node, int c, vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; color[node]=c; if(!flag) return; int nextColor=(c==RED?GREEN:RED); for(int neighbour:graph[node]) &#123; if(color[neighbour]==UNCOLORED)&#123; dfs(neighbour, nextColor, graph); &#125; else if(color[neighbour]!=nextColor)&#123; flag = false; return; &#125; &#125; &#125; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int n=graph.size(); color.assign(n,UNCOLORED);//先把图中每个点初始化为未涂色 flag = true; for(int i=0;i&lt;n;i++)&#123; if(color[i]==UNCOLORED)&#123; dfs(i, RED, graph); &#125; &#125; return flag; &#125;&#125;; bfs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;private: static constexpr int UNCOLORED = 0; static constexpr int RED = 1; static constexpr int GREEN = 2; vector&lt;int&gt; color; //记录节点涂色的情况 bool flag; //记录是否是二分图public: bool bfs(int node, int c, vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; queue&lt;int&gt;Q; Q.push(node); color[node]=c; while(!Q.empty()) &#123; int front=Q.front(); Q.pop(); int nextColor=(color[front]==RED?GREEN:RED); for(int neighbor:graph[front]) &#123; if(color[neighbor]==UNCOLORED) &#123; color[neighbor]=nextColor; Q.push(neighbor); &#125; else if(color[neighbor]!=nextColor) return false; &#125; &#125; return true; &#125; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int n=graph.size(); color.assign(n,UNCOLORED);//先把图中每个点初始化为未涂色 flag = true; for(int i=0;i&lt;n;i++)&#123; if(color[i]==UNCOLORED)&#123; flag = bfs(i, RED, graph); if(!flag) return flag; &#125; &#125; return true; &#125;&#125;; ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机启动的过程]]></title>
    <url>%2F2020%2F07%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[卡特兰数]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[二分法边界值问题总结]]></title>
    <url>%2F2020%2F07%2F02%2F%E4%BA%8C%E5%88%86%E6%B3%95%E8%BE%B9%E7%95%8C%E5%80%BC%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[二分法边界值问题总结一、结论先说结论，二分边界值一般有两种正确的写法： 第一种写法，二分的区间左闭右开，[left, right)： 123456789101112int left=0,right=nums.size();//right取不到int mid=0;while(left&lt;right)//这里是小于号&#123; mid=left+(right-left)/2;//一般都这么写，防止left+right溢出 if(nums[mid]==target) return mid; if(nums[mid]&lt;target) left=mid+1; else right=mid;//注意&#125; 第二种写法，二分的区间左右都是闭的，[left, right]： 123456789101112int left=0,right=nums.size()-1;//right能取到int mid=0;while(left&lt;=right)//这里是小于等于&#123; mid=left+(right-left)/2; if(nums[mid]==target) return mid; if(nums[mid]&lt;target) left=mid+1; else right=mid-1;//注意&#125; 二、原理]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[minecraft常用指令]]></title>
    <url>%2F2020%2F01%2F17%2Fminecraft%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[/gamerule mobGriefing false 关闭爆炸破坏方块 /gamerule doFireTick false 关闭火势蔓延 /gamerule keepInventory true 开启死亡不掉落 /difficulty 0 调整难度，0为和平，1为简单，2为普通，3为困难 /spawnpoint [玩家] 设置玩家的出生点为脚下 /setworldspawn 设置全服玩家的出生点为脚下]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加和删除live2D模型]]></title>
    <url>%2F2020%2F01%2F17%2Fhexo%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4live2D%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[添加live2d模型]]></content>
  </entry>
  <entry>
    <title><![CDATA[postgresql入门]]></title>
    <url>%2F2019%2F10%2F12%2Fpostgresql%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[postgresql 常用指令 在命令行输入 psql -l localhost -U postgres 连接本地的数据库，用户名为postgres； 指令 功能 \l 显示所有数据库 \d 显示当前库中所有表 \d [表名] 显示该表内容 \q 断开与数据库的连接 \c - [user] 切换到用户user \c [库名] 进入该数据库 alter table 表名 add (字段 字段类型) [ default &#39;输入默认值&#39;] [null/not null] ;举例：ALTER TABLE employee ADD spbh varchar(20) NOT NULL Default 0 备份数据库：在命令行输入pg_dump -h localhost -U postgres &quot;student&quot; &gt; &quot;d:\student.sql&quot;或者pg_dump -h localhost -U postgres -d student -f &quot;d:\ student.sql&quot; -h: 服务器地址； -U: 用户名; -d: 待备份数据库； -f: 输出文件名(或者目录) -F: 备份文件输出格式 (custom, directory,tar, plain text[默认]), -s: 只转储模式, 不包括数据 数据库还原：先使用SQL语句建立Student数据库，再利用备份的.sql文件进行还原。打开cmd.exe运行程序，切换到postgresql的bin目录下面（如果已经配置环境变量，不需要切换），使用以下命令进行还原：psql -h localhost -U postgres -d &quot;student&quot; &lt; &quot;d:\student.sql&quot;或者：pg_restore -h localhost -U postgres -d &quot;student&quot; &lt; &quot;d:\student.sql&quot; 修改表中数据update [表名] set [目标字段名]=[目标值] where [该行特征]]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux服务器的screen简单使用]]></title>
    <url>%2F2019%2F10%2F09%2Flinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84screen%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[远程连接服务器时，当你断开ssh窗口，当前的操作也会终止，这时候需要用到screen来保持当前窗口在后台运行。 Screen 常用指令 screen -S yourname -&gt; 新建一个叫yourname的sessionscreen -ls -&gt; 列出当前所有的sessionscreen -r yourname -&gt; 回到yourname这个sessionscreen -d yourname -&gt; 远程detach某个sessionscreen -X -S yourname -&gt; 关闭这个session Screen 常用操作 Ctrl-a d -&gt; detach，暂时离开当前session 关于Screen详细解析点此]]></content>
  </entry>
  <entry>
    <title><![CDATA[MNIST数据集入门]]></title>
    <url>%2F2019%2F07%2F14%2FMNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[引言相信很多深度学习的初学者都会触碰mnist数据集，tensorflow官方教程里也将这个数据集当做示例来供新手入门练手，但是其并没有详细讲解mnist的内部构造，下面就来介绍一下 简介MNIST是一个入门级的计算机视觉数据集，它包含各种手写数字图片]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>mnist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft开服教程]]></title>
    <url>%2F2019%2F07%2F02%2FMinecraft%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[几点说明 本篇为我的世界服务端搭建的教程，简单来说就是教你如何开服，与小伙伴在同一个世界里玩耍。 当然，如果你的服务端搭建在远程vps上就可以远程联机，如果服务端只是在你本地运行的话那只有和你同属局域网的人才能联机。 Spigot 纯净服务端搭建我本人并不推荐官方的服务端，不能安装插件，优化也不怎么样，可以说，Spigot/Bukkit 是当前最稳定高效的纯净服务端了，并且其有强大的社区，各种各样的插件，可玩性是相当的高。下面就来说说该如何搭建 spigot 1.12.2 服务端。 首先要下载 spigot 1.12.2 服务端核心。这个服务端核心在官网是找不到的，你只能下载到构建工具，点此直接下载服务端核心 百度网盘提取码:cw2g。 新建一个文件夹，就取名叫 server 吧，然后把刚才下载的spigot-1.12.2.jar文件丢进去。 在 server 文件夹内新建一个文件，将其改名为 run.bat，用编辑器打开，复制这一段代码进去并保存： 12Java -jar -Xms1G -Xmx2G spigot-1.12.2.jar noguiPAUSE 其实这是个windows批处理文件，之后你双击这个文件就相当于在命令行输入了这些语句，这样开服就方便些，不需要每次都输命令那么麻烦。简单解释一下这些参数的含义吧： Java -jar 是指用java运行这个jar包，也就是后面那个spigot-1.12.2，就是服务端的核心； -Xms1G 运行服务器的最小内存，这里给了1G； -Xmx2G 运行服务器的最大内存，这里给了2G，当然你可以根据实际情况修改； nogui 指不启用gui，因为你服务端本来就没有gui； PAUSE 这行让你在关闭服务器之后不会立刻关闭命令行。 双击 run.bat 文件，会自动跳出了命令行，然后报错，这时关闭命令行，你会发现 server 文件夹里多出来一些东西，这时打开 eula.txt ,将 eula=false 改成 eula=true ，表示你同意mojang的eula协定。 再次双击 run.bat 文件，等待它生成一些配置文件和加载世界结束后，服务器就能正常运行了。 但这还没有结束，你会发现如果不用正版账号根本进不去服务器。所以要用编辑器打开 server.properties ，找到 online-mode=true 这一行，将其改为 online-mode=false ，意思就是关闭在线模式，这样用离线模式就能登录服务器了。 现在服务器已经搭建成功，接下来你要知道你的服务器地址，打开命令行，输入 ipconfig ，回车，查看你的ipv4地址，复制，然后打开游戏客户端，进入多人游戏，点击 添加服务器 按钮，在服务器地址框里粘贴刚才复制的ip，在后面加上端口号25565，中间要加上冒号”:”，这里要注意一定是英文的冒号，如果是中文冒号客户端就找不到服务器，之后点击 完成 按钮。 一切就绪，现在点击加入服务器按钮就可以进入游戏，同时你可以将服务器地址和端口号告诉别人和你一起联机，前提是要在一个内网下，不过一般高校的校园网内都是能联机的。]]></content>
      <categories>
        <category>Minecraft</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spigot 1.12.2 Tutorial 01 Spigot的前世今生]]></title>
    <url>%2F2019%2F06%2F29%2FSpigot-1-12-2-Tutorial-01-Spigot%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%2F</url>
    <content type="text"></content>
      <categories>
        <category>Minecraft</category>
        <category>Spigot</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Plugin</tag>
        <tag>Spigot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft 1.12.2 Mod Tutorial 02 你的第一个mod]]></title>
    <url>%2F2019%2F06%2F27%2FMinecraft-1-12-2-Mod-Tutorial-02-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAmod%2F</url>
    <content type="text"><![CDATA[一、解读Example Mod二、构建并发布你的mod]]></content>
      <categories>
        <category>Minecraft</category>
        <category>Forge</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Mod</tag>
        <tag>Forge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Minecraft 1.12.2 Mod Tutorial 01 搭建开发环境]]></title>
    <url>%2F2019%2F06%2F26%2FMinecraft-1-12-2-Mod-Tutorial-01-%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一、安装Java既然要写mod，那么java必不可少，首先我们就来安装jdk (java development kit)。jdk可以去官网下载。下载完毕后一路下一步即可安装。 二、安装IntelliJ IDEA这里更推荐用IDEA来进行mod开发，原因就是非常好用并且IDEA有关于mc开发的插件。同样给出下载链接Intellij IDEA 官网下载。社区版即可，如果有教育邮箱可以免费使用付费版本，下载后按照流程安装即可。 三、搭建mod开发环境1.下载mdkmdk可以直接去Forge官网下载推荐的稳定版本Mdk 1.12.2-14.23.5.2768 2.解压mdk将下载好的Mdk解压到你的工程目录，然后我们用编辑器打开build.gradle文件，在最下面加上下面一段代码，目的是将构建的编码改为UTF-8。123tasks.withType(JavaCompile)&#123; options.encoding = "UTF-8"&#125; 其他部分改不改都无所谓，不过你也可以自己研究研究这个文件的其他部分。 3.构建环境在当前目录打开命令行，输入这个命令1gradlew setupDecompWorkspace idea 接下来就是漫长的等待，当出现 build successful 就是构建成功了。 4.在IDEA中运行项目]]></content>
      <categories>
        <category>Minecraft</category>
        <category>Forge</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Mod</tag>
        <tag>Forge</tag>
      </tags>
  </entry>
</search>
