<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[支持向量机(SVM)]]></title>
    <url>%2F2020%2F10%2F21%2F%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA-SVM%2F</url>
    <content type="text"><![CDATA[一、间隔与支持向量 样本集：$D={(\pmb{x_1},y_1),(\pmb{x_2},y_2),…,(\pmb{x_m},y_m)},y_i\in{-1,+1}$ 划分超平面：$\pmb{w^Tx}+b=0$ 其中$\pmb{w}=(w_1;w_2;…;w_d)$为法向量，决定了超平面的方向； $b$为位移项，决定了超平面与原点之间的距离 二、对偶问题三、核函数四、软间隔与正则化五、支持向量回归六、核方法]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树]]></title>
    <url>%2F2020%2F10%2F18%2F%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[（看完了西瓜书决策树(decision trees)这一章，简单的做一下总结，理论参考了《机器学习》，代码参考了《机器学习实战》） 一、基本流程123456789101112131415161718192021222324输入：训练集 D=&#123;(x1,y1),...,(xm,ym)&#125;;属性集 A=&#123;a1,...,ad&#125;.过程：函数TreeGenerate(D,A)生成节点 node;if D中样本全属于同一类别C then 将node标记为C类叶节点;returnend ifif A=ø OR D中样本在A上取值相同 then 将node标记叶节点，其类别标记为D中样本数最多的类;returnend if从A中选择最优划分属性a*;for a*的每一个值av* do 为node生成每一个分支; 令Dv表示D中在a*上取值为av*的样本子集； if Dv为空 then 将分支节点标记为叶节点，其类别标记为D中样本最多的类;return else 以TreeGenerate(Dv,A-&#123;a*&#125;)为分支节点 end ifend for输出：以node为根节点的一棵决策树 对应的代码如下： 123456789101112131415161718192021222324def createTree(dataSet, labels): """ 构建决策树 :param dataSet: 数据集D :param labels: 属性集A :return: 构建好的决策树，是嵌套字典的形式 """ classList = [example[-1] for example in dataSet] # 数据集的所有类标签 # （以下两行）类别完全相同则停止继续划分 if classList.count(classList[0]) == len(classList): return classList[0] # （以下两行）遍历完所有特征时返回出现次数最多的 if len(dataSet[0]) == 1: return majorityCnt(classList) bestFeat = chooseBestFeatureToSplit(dataSet) bestFeatLabel = labels[bestFeat] # 当前数据集选取的最好特征 myTree = &#123;bestFeatLabel: &#123;&#125;&#125; del (labels[bestFeat]) featValues = [example[bestFeat] for example in dataSet] uniqueVals = set(featValues) # 得到当前数据集包含的所有属性值 for value in uniqueVals: subLabels = labels[:] # 深拷贝 myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels) return myTree 二、划分选择决策树学习的关键在于如何选择最优划分属性。一般而言，随着划分过程不断进行，我们希望决策树的分支节点所包含的样本尽可能属于同一类别，即节点的“纯度(purity)越来越高”。经典的属性划分方法有以下三种： 1. 信息增益 “信息熵”是度量样本集合纯度最常用的一种指标，假定当前样本集合D中第$k$类样本所占比例为 $p_k(k=1,2,…,|y|)$，则 $D$的信息熵定义为： Ent(D)=-\sum_{k=1}^{|y|}p_klog_2p_k $Ent(D)$的值越小,则$D$的纯度越高 计算信息熵时约定：若 $p=0$，则$plog_2p=0$ $Ent(D)$的最小值为0，最大值为 $log_2|y|$ 代码如下： 123456789101112131415161718def calcShannonEnt(dataSet): """ 计算数据集的香农熵 :param dataSet: 数据集 :return: 香农熵 """ numEntries = len(dataSet) # 获取数据集中实例的总数 labelCounts = &#123;&#125; for featVec in dataSet: currentLabel = featVec[-1] if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 shannonEnt = 0.0 for key in labelCounts: prob = labelCounts[key] / numEntries shannonEnt -= prob * log(prob, 2) return shannonEnt 离散属性$a$有$V$个可能的取值${a^1,a^2,…,a^V}$，用$a$来进行划分，则会产生$V$个分支节点，其中第$v$个分支节点包含了$D$中所有在属性$a$上取值为$a^v$的样本，极为$D^v$。则可计算出用属性$a$对样本集$D$进行划分所得的“信息增益”： Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{|D^v|}{|D|}Ent(D^v)这个是信息增益的定义公式，在信息论中信息增益也称为互信息，其表示已知一个随机变量的信息后使得另一个随机变量的不确定性减少的程度。所以在这里，这个公式可以理解为在属性$a$ 的取值已知后数据集 $D$ 中类别 $k$ 的不确定性减小的程度。若根据某个属性计算得到的信息增益越大， 则说明在知道其取值后样本集的不确定性减小的程度越大，也即为书上所说的“纯度提升”越大。 根据信息增益选取属性的代码如下： 1234567891011121314151617181920212223def chooseBestFeatureToSplit(dataSet): """ 计算每一种划分的信息增益，选择具有最大信息增益的分法（ID3算法） :param dataSet: 数据集 :return: 最好的划分数据集的特征的索引 """ numFeatures = len(dataSet[0]) - 1 baseEntropy = calcShannonEnt(dataSet) # 整个数据集的原始香农熵 bestInfoGain = 0.0 # 信息增益：是熵的减少或数据无序度的减少 bestFeature = -1 for i in range(numFeatures): featList = [example[i] for example in dataSet] # 获取二维列表第i列的值 uniqueVals = set(featList) # 从列表中创建集合是Python语言得到列表中唯一元素值的最快方法 newEntropy = 0.0 for value in uniqueVals: subDataSet = splitDataSet(dataSet, i, value) prob = len(subDataSet) / len(dataSet) newEntropy += prob * calcShannonEnt(subDataSet) infoGain = baseEntropy - newEntropy if infoGain &gt; bestInfoGain: # 更新信息增益，取最大值 bestInfoGain = infoGain bestFeature = i return bestFeature ID3决策树学习算法[Quinlan,1986]以信息增益为准则来选择划分属性 存在的问题：信息增益对可取值数目较多的属性有所偏好 若把“西瓜的编号”也作为一个候选划分属性，则其信息增益一般远大于其他属性。显然，这样的决策树不具有泛化能力，无法对新样本进行有效预测。 2. 增益率 增益率定义： Gain\_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}其中 IV(a)=-\sum_{v=1}^V\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}称为属性$a$的“固有值”，属性$a$的可能取值数目越多（即$V$越大），则$IV(a)$的值通常就越大 存在的问题：增益率准则对可取值数目较少的属性有所偏好 C4.5[Quinlan,1993]使用了一个启发式：先从候选划分属性中找出信息增益高于平均水平的属性，再从中选取增益率最高的 3. 基尼指数 数据集$D$的纯度可用“基尼值”来度量： Gini(D)=\sum_{k=1}^{|y|}\sum_{k'\neq k}p_kp_{k'}=1-\sum_{k=1}^{|y|}p_k^2 基尼值反映了从$D$中随机抽取两个样本，其类别标记不一致的概率 $Gini(D)$越小，数据集$D$的纯度越高 属性a的基尼指数定义为： Gini\_index(D,a)=\sum_{v=1}^{V}\frac{|D^v|}{|D|}Gini(D^v)这个是数据集$D$中属性$a$的基尼指数的定义，它表示在属性$a$的取值已知的条件下，数据集$D$按照属性$a$的所有可能取值划分后的纯度，不过在构造CART分类树时并不会严格按照此公式来选择最优划分属性，主要是因为CART分类时一棵二叉树，如果用上面的公式去选出最优划分属性，无法进一步选出最优划分属性的最优划分点。CART分类树的构造算法如下： 首先，对每个属性$a$的每个取值$v$，将数据集$D$分为$a=v$和$a\neq v$两部分来计算基尼指数，即 Gini\_index(D,a)=\frac{|D^{a=v}|}{|D|}Gini(D^{a=v})+\frac{|D^{a\neq v}|}{|D|}Gini(D^{a\neq v}) 然后，选择基尼指数最小的属性及其对应取值作为最优划分属性和最优划分点； 最后，重复以上两部，直至满足停止条件。 应选择那个使划分后基尼指数最小的属性作为最优划分属性，即 a_*=\mathop{argmin}\limits_{a\in A}Gini\_index(D,a) CART[Breiman et al., 1984]采用“基尼指数”来选择划分属性 三、剪枝处理“剪枝”是决策树学习算法对付过拟合的主要手段。 用留出法判断决策树泛化性能是否提升，即预留一部分数据用作“验证集”已进行性能评估。 1. 预剪枝（提前终止某些分支的增长） 决策树生成过程中，对每个节点在划分前先进行评估，若当前节点的划分不能带来决策树泛化性能提升，则停止划分并将当前节点记为叶节点，其类别标记为训练样例数最多的类别。 优点： 降低过拟合风险 显著减少训练时间和测试时间开销 缺点：欠拟合风险 有些分支的当前划分虽然不能提升泛化性能，但在其基础上进行的后续划分却有可能导致性能显著提高。预剪枝基于“贪心”本质禁止这些分支展开，带来了欠拟合风险 2. 后剪枝（先生成一棵树，再回头剪枝） 先从训练集生成一棵完整的决策树，然后自底向上地对非叶节点进行考察，若将该节点对应的子树替换为叶节点能带来决策树泛化性能提升，则将该子树替换为叶节点。 优点：后剪枝比预剪枝保留了更多的分支，欠拟合风险小，泛化性能往往优于预剪枝决策树。 缺点：训练时间开销大，后剪枝过程是在生成完全决策树之后进行的，需要自底向上对所有非叶节点逐一考察。 四、连续与缺失值1. 连续值处理（连续属性离散化，二分法） 第一步：假定连续属性$a$在样本集$D$上出现$n$个不同的取值，从小到大排列，记为$a^1,a^2,…a^n$，基于划分点$t$，可将$D$分为子集$D_t^-$和$D_t^+$，其中$D_t^-$包含那些在属性$a$上取值不大于$t$的样本，$D_t^+$包含那些在属性$a$上取值大于$t$的样本。考虑包含$n-1$个元素的候选划分点集合 T_a=\{\frac{a^i+a^{i+1}}{2}|1\leq i \leq n-1\}即把区间$[a^i,a^{i-1})$的中位点$\frac{a^i+a^{i+1}}{2}$作为候选划分点。 第二步：采用离散属性值方法，考察这些划分点，选取最优的划分点进行样本集合的划分 \begin{aligned} Gain(D,a)&=\mathop{max}\limits_{t\in T_a}Gain(D,a,t) \\ &=\mathop{max}\limits_{t\in T_a}Ent(D)-\sum_{\lambda \in \{-,+\}}\frac{|D_t^\lambda|}{|D|}Ent(D_t^\lambda) \end{aligned}$\lambda \in {−, +}$表示属性 $a$ 的取值分别小于等于和大于候选划分点 $t$ 时的情形，也即当 $\lambda = −$ 时:$D_t^\lambda = D_t^{a\leq t}$，当 $\lambda = +$时:$D_t^\lambda = D_t^{a&gt;t}$ 其中$Gain(D,a,t)$是样本集$D$基于划分点$t$二分后的信息增益，于是，就可选择使$Gain(D,a,t)$最大化的划分点。 可将划分点设为该属性在训练集中出现的不大于中位点的最大值，从而使得最终决策树使用的划分点都在训练集中出现过。 需要注意的是，与离散属性不同，若当前节点划分属性为连续属性，该属性还可作为其后代节点的划分属性。 2. 缺失值处理 如何在属性值缺失的情况下划分属性选择？ 书上给了很多定义和公式，通俗的讲，其实就是拿无缺失的样本计算信息增益，然后乘上一个无缺失样本所占比例，就是该属性真实的信息增益。 给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分？ 若样本$x$在划分属性$a$上的取值已知，则将x划入与其取值对应的子节点，且样本全值在子节点中保持为$w_x$ 若样本$x$在划分属性$a$上的取值未知，则将$x$同时划入所有子节点，且样本权值在与属性值$a^v$对应的子节点中调整为$\tilde{r}_v·w_x$（只管来看，相当于让同一个样本以不同的概率划入不同的子节点中去） 五、多变量决策树 单变量决策树分类边界：轴平行 多变量决策树： 非叶节点不再是仅对某个属性，而是对属性的线形组合 每个非叶节点是一个形如$\sum_{i=1}^dw_ia_i=t$的线形分类器，其中$w_i$是属性$a_i$的权重，$w_i$和$t$可在该节点所含的样本集和属性集上学得。 六、总体代码这个只是基于信息增益的方法生成的决策树，并且没有做剪枝。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178from math import logimport operatordef createDataSet(): """ 创建数据集 :return: 数据集，标签 """ dataSet = [[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']] labels = ['no surfacing', 'flippers'] return dataSet, labelsdef calcShannonEnt(dataSet): """ 计算数据集的香农熵 :param dataSet: 数据集 :return: 香农熵 """ numEntries = len(dataSet) # 获取数据集中实例的总数 labelCounts = &#123;&#125; for featVec in dataSet: currentLabel = featVec[-1] if currentLabel not in labelCounts.keys(): labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 shannonEnt = 0.0 for key in labelCounts: prob = labelCounts[key] / numEntries shannonEnt -= prob * log(prob, 2) return shannonEntdef splitDataSet(dataSet, axis, value): """ 按照给定特征划分数据集 :param dataSet: 数据集 :param axis: 给定的特征的列号 :param value: 该特征的值 :return: 按该特征抽取出的数据集 """ retDataSet = [] for featVec in dataSet: if featVec[axis] == value: reducedFeatVec = featVec[:axis] reducedFeatVec.extend(featVec[axis + 1:]) retDataSet.append(reducedFeatVec) return retDataSetdef chooseBestFeatureToSplit(dataSet): """ 计算每一种划分的信息增益，选择具有最大信息增益的分法（ID3算法） :param dataSet: 数据集 :return: 最好的划分数据集的特征的索引 """ numFeatures = len(dataSet[0]) - 1 baseEntropy = calcShannonEnt(dataSet) # 整个数据集的原始香农熵 bestInfoGain = 0.0 # 信息增益：是熵的减少或数据无序度的减少 bestFeature = -1 for i in range(numFeatures): featList = [example[i] for example in dataSet] # 获取二维列表第i列的值 uniqueVals = set(featList) # 从列表中创建集合是Python语言得到列表中唯一元素值的最快方法 newEntropy = 0.0 for value in uniqueVals: subDataSet = splitDataSet(dataSet, i, value) prob = len(subDataSet) / len(dataSet) newEntropy += prob * calcShannonEnt(subDataSet) infoGain = baseEntropy - newEntropy if infoGain &gt; bestInfoGain: # 更新信息增益，取最大值 bestInfoGain = infoGain bestFeature = i return bestFeaturedef majorityCnt(classList): """ 获得类别数目最多的类别名称 :param classList: 类别列表 :return: 类别数目最多的类别名称 """ classCount = &#123;&#125; for vote in classList: if vote not in classCount.keys(): classCount[vote] = 0 classCount[vote] += 1 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) # 按照字典的值进行排序，逆序 return sortedClassCount[0][0] # 返回字典的第一个元素的键def createTree(dataSet, labels): """ 构建决策树 :param dataSet: 数据集 :param labels: 属性集 :return: 构建好的决策树，是嵌套字典的形式 """ classList = [example[-1] for example in dataSet] # 数据集的所有类标签 # （以下两行）类别完全相同则停止继续划分 if classList.count(classList[0]) == len(classList): return classList[0] # （以下两行）遍历完所有特征时返回出现次数最多的 if len(dataSet[0]) == 1: return majorityCnt(classList) bestFeat = chooseBestFeatureToSplit(dataSet) bestFeatLabel = labels[bestFeat] # 当前数据集选取的最好特征 myTree = &#123;bestFeatLabel: &#123;&#125;&#125; del (labels[bestFeat]) featValues = [example[bestFeat] for example in dataSet] uniqueVals = set(featValues) # 得到当前数据集包含的所有属性值 for value in uniqueVals: subLabels = labels[:] # 深拷贝 myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels) return myTreedef classify(inputTree, featLabels, testVec): """ 使用决策树分类 :param inputTree: DecisionTrees :param featLabels: 特征列表 :param testVec: 需要分类的特征的值列表 :return: 所分的类别 """ firstStr = list(inputTree.keys())[0] secondDict = inputTree[firstStr] featIndex = featLabels.index(firstStr) # 将标签字符串转化为索引，使用index方法查找当前列表中第一个匹配firstStr变量的元素 classLabel = '' for key in secondDict.keys(): if testVec[featIndex] == key: if type(secondDict[key]).__name__ == 'dict': classLabel = classify(secondDict[key], featLabels, testVec) else: classLabel = secondDict[key] return classLabeldef storeTree(inputTree, filename): """ 将训练好的决策树字典对象保存到文件里 :param inputTree: DecisionTrees :param filename: 文件名（如果没有，会新建） :return: None """ import pickle # 使用pickle序列化对象，可以保存到磁盘上，需要时候读取 fw = open(filename, 'wb') # 注意python3必须是二进制写入'wb'，而不能是'w' pickle.dump(inputTree, fw) fw.close()def grabTree(filename): """ 读取磁盘上的决策树文件 :param filename: 文件名 :return: 保存在磁盘里的决策树字典对象 """ import pickle fr = open(filename, 'rb') return pickle.load(fr)if __name__ == '__main__': myDat, labels = createDataSet() myTree = createTree(myDat, labels) storeTree(myTree, 'classifierStorage.txt') print(grabTree('classifierStorage.txt')) # myDat, labels = createDataset() # print(classify(myTree, labels, [1, 0])) # print(classify(myTree, labels, [1, 1])) # ent = calcShannonEnt(myDat) # print(createTree(myDat, labels)) # print(splitDataSet(myDat, 0, 1)) # print(splitDataSet(myDat, 0, 0)) 用西瓜书里的数据集跑了一下，得出的决策树如图：]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Decision Trees</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息熵是什么]]></title>
    <url>%2F2020%2F10%2F17%2F%E4%BF%A1%E6%81%AF%E7%86%B5%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[信息熵是什么？在西瓜书里看到决策树那一章时有这么一个概念：信息熵。 书里直接给出了定义：“信息熵”（information entropy）是度量样本集合纯度最常用的一种指标。假定当前样本集合$D$中第$k$类样本所占的比例为$p_k(k=1,2,…,|y|)$，则$D$的信息熵定义为 Ent(D)=-\sum^{|y|}_{k=1}p_klog_2p_k $Ent(D)$的值越小，则$D$的纯度越高。 计算信息熵时的约定：若$p=0$，则$plog_2p=0$ $Ent(D)$的最小值为$0$，最大值为$log_2|y|$ 书中没有给出熵的定义的由来（感觉没有必要，不然篇幅太长了），后来在知乎上看到信息熵是什么？ - YJango的回答 - 知乎，解释的非常清晰。 知乎的回答是视频形式的，这里简单的总结一下： 信息熵是度量事件的不确定性的 消除熵=获取信息，信息与熵数量相等，意义相反 可以把抛掷一枚硬币看成是1bit的熵，那么所有事件的信息熵都可以看成抛掷多少枚硬币的量 比如一道题有ABCD四个选项（正确答案是C），那么这个问题相当于抛掷两枚硬币，熵是$log_24=2bit$，那么当我知道C有50%的可能是正确答案时，此时的熵又是多少？ 此时对于我而言，ABCD是正确答案的概率分别是$\frac{1}{6},\frac{1}{6},\frac{1}{2},\frac{1}{6}$，此时的熵可以看成是四个选项的信息量乘以他们各自的发生概率的总和，那么怎么求A的信息量呢？ 我们知道，概率为$\frac{1}{6}$的事件相当于有6个等概率的事，发生了其中一个事件的值，那么就要求抛掷多少枚硬币会有6种等概率的情况发生呢？显然是$log_26$。 所以，此时这道题的信息量为$\frac{1}{6}log_26+\frac{1}{6}log_26+\frac{1}{2}log_22+\frac{1}{6}log_26=1.79bit$ 所以，“C有50%的可能是正确答案”这条信息给我提供的信息量就是$2-1.79=0.21bit$ 这时候我们就可以得出熵的定义式 Ent(D)=\sum^{|y|}_{k=1}p_klog_2\frac{1}{p_k}=-\sum^{|y|}_{k=1}p_klog_2p_k]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[337.打家劫舍III]]></title>
    <url>%2F2020%2F08%2F05%2F337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII%2F</url>
    <content type="text"><![CDATA[题目链接337.打家劫舍III 题目描述在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 样例1234567891011示例1:输入: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 1234567891011示例2:输入: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 解题思路从题目描述中我们大概可以猜到这是一个动态规划的题，但是这是在树上的动归，可以用深搜的方法来解决。我们可以定义两个数组： f[o]代表选中当前节点的最大值 g[o]代表不选当前节点的最大值 那么我们可以得到转移方程就是： f[o] = o-&gt;val + g[o-&gt;left] + g[o-&gt;right] 因为不能偷两家相邻的节点，所以如果偷了当前节点，就不能偷他的左右儿子节点 g[o] = max(f[o-&gt;left], g[o-&gt;left]) + max(f[o-&gt;right], g[o-&gt;right]) 如果不偷当前这家，就可以偷他的左右儿子，但也可以不偷，选择更优的的结果。 代码12345678910111213141516171819class Solution &#123;public: unordered_map&lt;TreeNode*, int&gt; f,g; int rob(TreeNode* root) &#123; dfs(root); return max(f[root], g[root]); &#125; void dfs(TreeNode* o) &#123; if(!o) return; dfs(o-&gt;left); dfs(o-&gt;right); f[o]=o-&gt;val+g[o-&gt;left]+g[o-&gt;right]; g[o]=max(f[o-&gt;left], g[o-&gt;left])+max(f[o-&gt;right], g[o-&gt;right]); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网复习重点]]></title>
    <url>%2F2020%2F07%2F28%2F%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[一、计算机网络体系结构（一）计算机网络概述1. 概念、组成、功能和分类 概念：计算机网络是互连的、自治的计算机集合 组成 组成部分：硬件、软件、协议 工作方式：边缘部分、核心部分 功能组成：通信子网、资源子网 功能 数据通信 资源共享 分布式处理、提高可靠性、负载均衡 分类 分布范围：广域网、城域网、局域网、个人区域网 使用者：公用网、专用网 交换技术：电路交换、报文交换、分组交换 拓扑结构：总线型、星型、环型、网状型 传输技术：广播式、点对点 2. 性能指标 速度相关 速率：实际速率 带宽：理论最大最大速率 吞吐量 时间相关 时延 传输时延（主机内部到信道） 传播时延（电磁波在信道中传输） 时延带宽积：传播时延$\times$ 带宽 往返时延RTT：传播时延$\times$2 利用率：利用率越高，网络越拥堵 信道利用率：$\frac{有数据通过时间}{(有+无)数据通过时间}$ 网络利用率：信道利用率加权平均值 （二）计算机网络体系结构与参考模型二、物理层（一）通信基础（二）传输介质（三）物理层设备三、数据链路层（一）（二）四、网络层五、传输层六、应用层]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统复习重点]]></title>
    <url>%2F2020%2F07%2F23%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[一、操作系统概述 1. 操作系统的概念、功能和目标 概念（定义） 操作系统控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机系统的工作和资源的分配，以提供给用户和其他软件方便的借口和环境，它是计算机系统中最基本的 系统软件。 功能 资源的管理者 处理机管理 存储器管理 文件管理 设备管理 向用户提供服务 命令接口（用户直接使用） 联机命令接口：命令行式 脱机命令接口：批处理式 程序接口：即“系统调用”，又叫“广义指令”，用户通过程序间接使用 GUI（图形用户界面） 对硬件机器的扩展：扩充机器 目标：方便用户使用 2. 操作系统的特征 并发（与共享互为存在条件） 共享：即资源共享 互斥共享方式（如对摄像头设备的共享使用） 同时共享方式（如对硬盘资源的共享使用） 虚拟 空分复用技术（如虚拟存储技术） 时分复用技术（如虚拟处理器技术） 异步异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是程序的异步性。 显然，如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。只有系统拥有并发性，才可能导致异步性。 3. 操作系统的发展与分类 手工操作系统阶段 缺点：人机速度矛盾 批处理阶段 单道批处理系统（引入脱机输入输出技术） 优点：缓解人机速度矛盾 缺点：资源利用率依然很低 多道批处理系统（操作系统开始出现） 优点：多道程序并发执行，资源利用率高 缺点：不提供人机交互功能 分时操作系统 优点：提供人机交互功能 缺点：不能优先处理紧急任务 实时操作系统 硬实时操作系统（必须在绝对严格的规定时间内完成处理） 软实时操作系统（能接受偶尔违反时间规定） 优点：能优先处理紧急任务 网络操作系统 分布式操作系统 个人计算机操作系统 4. OS的运行机制和体系结构 运行机制 两种指令 特权指令（不允许用户程序使用）：如内存清零指令 非特权指令：如普通的运算指令 两种处理器状态 核心态（管态） 用户态（目态）用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为核心态。 用户态到核心态是通过 中断 实现的，并且中断是唯一途径。 核心态到用户态的切换是通过 执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”。 两种程序 内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。 应用程序：为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。 操作系统内核 时钟管理：实现计时功能 中断管理：负责实现中断机制 原语 是一种特殊的程序 处于操作系统最底层，是最接近硬件的部分 这种程序的运行具有原子性，只能一气呵成，不可中断 运行时间较短、调用频繁 对系统资源进行管理的功能 进程管理 存储器管理 设备管理 操作系统的体系结构 大内核 将操作系统的主要功能模块都作为系统内核，运行在核心态 优点：高性能 缺点：内核代码庞大，结构混乱，难以维护 微内核 只把基本的功能保留在内核 优点：内核功能少，结构清晰，方便维护 缺点：需要繁琐地在核心和用户态之间切换，性能低 5. 中断和异常 中断机制的诞生：为了实现多道程序并发执行而引入的一种技术 中断的概念和作用 发生中断，就意味着操作系统介入开展管理工作，CPU会立即进入核心态 “中断”是CPU从用户态进入核心态的唯一路径 中断的分类 内中断（也称为异常、例外、陷入，信号来源于CPU内部，与当前执行的指令有关） 自愿中断——指令中断：如系统调用时使用的访管指令（又叫陷入指令、trap指令） 强迫中断 硬件故障：如缺页 软件中断：如整数除0 外中断（也叫中断，信号来源于CPU外部，与当前执行的指令无关） 外设请求：如I/O操作完成发生的中断信号 人工干预：如用户强行终止一个进程 另一种分类方式： 内中断（内部异常） 陷进、陷入（trap）：有意而为之的异常，如系统调用 故障（fault）：由错误条件引起的，可能被故障处理程序修复，如缺页 终止（abort）：不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除0 外中断 I/O中断请求 人工干预 外中断的处理过程 每条指令执行结束后，CPU检查是否有外部中断信号 若有外部中断信号，则需要保护被中断进程的CPU环境（PSW，PC，通用寄存器） 根据中断信号类型转入相应的中断处理程序 恢复原进程的CPU环境并退出中断，返回原进程继续往下执行 6. 系统调用 什么是系统调用，有何作用？ 操作系统提供给应用程序使用的接口 应用程序通过系统调用来请求获得操作系统的服务 系统调用会使处理器从用户态进入核心态 分类： 设备管理 文件管理 进程控制 进程通信 内存管理 凡是与资源有关的操作、会直接影响到其他进程的操作，一定需要操作系统介入，即需要通过系统调用来实现。 系统调用和库函数的区别 系统调用时操作系统向上层提供的接口 有的库函数是对系统调用的进一步封装 当今编写的应用程序大多数是通过高级语言提供的库函数间接地进行系统调用 系统调用背后的过程 传递系统调用参数 执行陷入指令（唯一一条只能在用户态执行，而不能在核心态执行的指令） 执行系统调用相应服务程序 返回用户程序 注意 系统调用发生在 用户态，对系统调用的处理发生在 核心态。 执行陷入指令会产生内中断，使处理器从用户态进入核心态。 陷入指令又叫trap指令、访管指令 二、进程管理(一)进程与线程 1. 进程的定义、组成、组织方式、特征 定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位 组成： PCB 进程描述信息 进程控制和管理信息 资源分配清单 处理机相关信息 程序段：存放要执行的程序代码 代码段：存放程序运行过程中处理的各种数据 组织形式： 链接方式：按进程状态将PCB分为多个队列 索引方式：按照进程状态建立几张索引表，各表指向一个PCB 特征： 动态性：进程的最基本特征 并发性 独立性：进程是系统进行资源分配、调度的独立单位 异步性：各进程以不可预知的速度向前推进，可能导致运行结果的不确定性 结构性 2. 进程的状态与转换 状态 运行状态：有CPU，有其他所需资源 就绪状态：无CPU，有其他所需资源 阻塞状态：无CPU，无其他所需资源 创建状态：操作系统为新进程分配资源、创建PCB 终止状态：操作系统回收进程的资源、撤销PCB 进程状态间的转换 就绪态—&gt;运行态：进程被调度 运行态—&gt;就绪态：时间片到，或CPU被其他高优先级的进程抢占 运行态—&gt;阻塞态：等待系统资源分配，或等待某事件发生（主动行为） 阻塞态—&gt;就绪态：资源分配到位，等待的事件发生（被动行为） 创建态—&gt;就绪态：系统完成创建进程相关的工作 运行态—&gt;终止态：进程运行结束，或运行过程中遇到不可修复的错误 3. 进程控制 基本概念 进程控制就是要实现进程状态的转换 进程控制用原语实现 原语用关/开中断来实现 原语是一种特殊的程序 原语的执行必须一气呵成，不可中断 相关原语 进程的创建 进程的终止 进程的阻塞 进程的唤醒 进程的切换 4. 进程通信 共享存储 设置一个共享空间 要互斥地访问共享空间 两种方式 基于数据结构（低级） 基于存储区的共享（高级） 消息传递 传递结构化的消息（消息头/消息体） 系统提供“发送/接受原语” 两种方式： 直接通信方式：消息直接挂到接收进程的消息缓冲队列上 间接通信方式：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式” 管道通信 设置一个特殊的共享文件（管道），其实就是一个缓冲区 一个管道只能实现半双工通信 实现双向同时通信要建立两个管道 各进程要互斥访问管道 写满时，不能再写。读空时，不能再读 没写满，不能读。没读空，不能写 5. 线程概念和多线程模型 什么是线程，为什么要引入线程？ 可理解为“轻量级进程” 可增加并发度，减少并发带来的开销 引入线程机制后，有什么变化？（和传统的进程机制对比） 资源分配、处理机调度 并发性 （实现并发的）系统开销 线程有哪些重要的属性 线程是处理机调度的单位，进程是资源分配的单位 同一进程的各线程共享进程拥有的资源 同一进程内的线程切换不会导致进程切换 线程的实现方式 用户级线程：从用户视角看的线程 内核级线程：从操作系统视角看的进程（内核级线程才是处理机分配的单位） 组合方式：上述两种方式的结合 多线程模型 多对一模型 优点：进程管理开销小效率高 缺点：一个线程阻塞会导致整个进程都被阻塞（并发度低） 一对一模型 优点：各个线程可分配到多核处理机并行执行，并发度高 缺点：进程管理开销大 多对多模型：集二者之所长 (二)处理机调度 1. 处理机调度 基本概念：按某种算法选择一个进程将处理机分配给它 三个层次： 高级调度（作业调度）：按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 中级调度（内存调度）：按照某种规则，从挂起队列中选择合适的进程将其数据调回内存 低级调度（进程调度）：按照某种规则，从就绪队列中选择一个进程为其分配处理机 三层调度的联系、对比 高级调度： 外存—&gt;内存（面向作业） 发生频率：最低 中级调度： 外存—&gt;内存（面向进程） 发生频率：中等 低级调度： 内存—&gt;CPU 发生频率：最高 补充知识 为减轻系统负载，提高资源利用率，暂时不进行的进程会被调到外存而变成“挂起态” 七状态模型：在五状态模型的基础上加入了“就绪挂起”和“阻塞挂起”两种状态 2. 进程调度 进程调度的时机 什么时候需要进程调度？ 主动放弃： 进程正常终止 运行过程中发生异常而终止 主动阻塞（如 等待IO） 被动放弃： 分给进程的时间片用完 有更紧急的事情需要处理（如IO中断） 有更高优先级的进程进入就绪队列 什么时候不能进行进程调度？ 在处理中断的过程中 进程在操作系统内核程序临界区中（进程处于普通临界区中是可以调度的） 原子操作过程中（原语） 进程切换与过程 狭义的“调度”和“切换”的区别 切换过程 对原来运行进程各种数据的保存 对新的进程各种数据的恢复 重要结论：进程调度、切换时有代价的，并不是调度越频繁，并发度就越高 进程调度的方式 非剥夺调度方式（非抢占式）：只能由当前运行的进程主动放弃CPU 剥夺调度方式（抢占式）：可由操作系统剥夺当前进程的CPU使用权 3. 调度算法的评价指标 CPU利用率 利用率=\frac{忙碌时间}{总时间} 系统吞吐量 系统吞吐量=\frac{总共完成了多少道作业}{总共花了多少时间} 周转时间 周转时间 = 作业完成时间-作业提交时间 \\ 平均周转时间 = \frac{各作业周转时间之和}{作业数} \\ 带权周转时间 = \frac{作业周转时间}{作业实际运行时间} \\ 平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数} 等待时间 进程或作业等待被服务的时间之和 平均等待时间即各个进程或作业等待时间的平均值 响应时间：从用户提交请求到首次产生响应所用的时间 4. 调度算法（适用于批处理系统） 算法 可抢占 优点 缺点 考虑等待时间or运行时间？ 是否会导致饥饿？ FCFS 非抢占式 公平；实现简单 对短作业不利 等待时间 不会 SJF/SPF 默认为非抢占式，也有SJF的抢占式版本最短剩余时间优先算法（SRTN） “最短的”平均等待and周转时间 对长作业不利，可能导致饥饿；难以做到正真的短作业优先 运行时间 会 HRRN 非抢占式 上述两种算法的权衡折中，综合考虑的等待时间和运行时间 等待时间和运行时间 不会 注意：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。 5. 调度算法（适用于交互式系统） 时间片轮转（RR，Round-Robin） 算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。 用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片） 是否可抢占？如进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。有时钟装置发出时钟中断来通知CPU时间片已到 优缺点 公平；响应快，适用于分时操作系统； 缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度 是否会导致饥饿？不会 补充：时间片太大，退化为先来先服务；时间片太小，切换进程开销大。 优先级调度算法 多级反馈队列调度算法 总结： 算法 可抢占？ 优点 缺点 会导致饥饿？ 补充 时间片轮转 抢占式 公平，适用于分时系统 频繁切换有开销，不区分优先级 不会 时间片太大或太小有何影响？ 优先级调度 有抢占式也有非抢占式的 区分优先级，适用于实时系统 可能会导致饥饿 会 动态/静态优先级。各类进程如何设置优先级？如何调整优先级？ 多级反馈队列 抢占式 平衡优秀 一般不说它有缺点，不过可能导致饥饿 会 注意：比起早起的批处理系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适用于交互式系统（比如UNIX使用的就是多级反馈队列调度算法）。 (三)进程同步 1. 同步、互斥 进程同步 并发性带来了异步性，有时需要通过进程同步解决这种异步的问题 有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的先后顺序 进程互斥 对临界资源的访问，需要互斥的进行。即同一时间段内只能允许一个进程访问该资源 四个部分 进入区：检查是否可以进入临界区，若可进入，需要“上锁” 临界区：访问临界资源的那段代码 退出区：负责“解锁” 剩余区：其余代码部分 需要遵循的原则 空闲让进：临界区空闲时，应允许一个进程访问 忙则等待：临界区正在被访问时，其他试图访问的进程需要等待 有限等待：要在有限时间内进入临界区，保证不会饥饿 让权等待：进不了临界区的进程，要释放处理机，防止忙等 2. 进程互斥的软件实现方法 单标志法 在进入区只做“检查”，不“上锁” 在退出区把临界资源的使用权转交给另一个进程（相当于在退出区既给另一进程“解锁”，又给自己“上锁”） 主要问题：不遵循“空闲让进”原则 双标志先检查 在进入区先“检查”后“上锁”，退出区“解锁” 主要问题：不遵循“忙则等待”原则 双标志后检查 在进入区先“加锁”后”检查“，退出区“解锁” 主要问题：不遵循“空闲让进、有限等待”原则，可能导致“饥饿” Peterson算法 在进入区“主动争取——主动谦让——检查对方是否想进——己方是否谦让” 主要问题：不遵循“让权等待”原则，会发生“忙等” 3. 进程互斥的硬件实现方法 中断屏蔽方法 使用开关中断指令实现 优点：简单高效 缺点：只适用于单处理机；只适用于操作系统内核进程 TestAndSet(TS指令/TSL指令) 步骤： old记录是否已被上锁 再将lock设为true 检查临界区是否已被上锁（若已上锁，则循环重复前几步） 优点：实现简单；适用于多处理机环境； 缺点：不满足“让权等待” Swap指令（XCHG指令）：逻辑上同TSL 4. 信号量机制 整型信号量 用一个整数型变量作为信号量，数值表示某种资源数 整型信号量与普通整型变量的区别：对信号量只能执行 初始化、P、V三种操作 整型信号量存在的问题：不满足让权等待原则 记录型信号量 S.value表示某种资源数，S.L指向等待该资源的队列 P操作中，一定是先S.value—，之后可能需要执行block原语 V操作中，一定是先S.value++，之后可能需要执行wakeup原语 注意：要能够自己腿短在什么条件下需要执行block或wakeup 可以用记录型信号量实现系统资源的“申请”和“释放” 可以用记录型信号量实现进程互斥、进程同步 5. 用信号量实现进程互斥、同步 实现进程互斥 分析问题，确定临界区 设置互斥信号量，初值为1 临界区之前对信号量执行P操作 临界区之后对信号量执行V操作 实现进程同步 分析问题，找出哪里需要实现“一前一后”的同步关系 设置同步信号量，初始值为0 在“前操作”之后执行V操作 在“后操作”之前执行P操作 实现进程的前驱关系 分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题 为每一对前驱关系设置同步信号量，初值为0 在每个“前操作”之后执行V操作 在每个“后操作”之前执行P操作 6. 信号量相关问题 生产者-消费者问题 多生产者-多消费者问题 吸烟者问题 读者-写者问题：计数器count 哲学家进餐问题 注意：同步信号量的P操作一定在互斥信号量的P操作之前 7. 管程（与类的封装特性相似） 为什么要引入管程：解决信号量机制编程麻烦、易出错的问题 组成 共享数据结构 对数据结构初始化的语句 一组用来访问数据结构的过程（函数） 基本特征 各外部进程/线程只能通过管程提供的特定“入口”才能访问共享数据 每次仅允许一个进程在管程内执行某个内部过程 补充 各进程必须互斥访问管程的特性是由编译器实现的 可在管程中设置条件变量及等待/唤醒操作以解决同步问题 (四)死锁 1. 死锁的概念 什么是死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进 进程死锁、饥饿、死循环的区别 死锁：至少是两个进程一起死锁，死锁进程处于阻塞状态 饥饿：可以只有一个进程饥饿，饥饿进程可能阻塞也可能就绪 死循环：可能只有一个进程发生死循环，死循环的进程可上处理机 死锁和饥饿是操作系统要解决的问题，死循环是应用程序员要解决的 死锁产生的必要条件 互斥条件：对必须互斥使用的资源的争抢才会导致死锁 不可剥夺条件：进程保持的资源只能主动释放，不可强行剥夺 请求和保持条件：保持着某些资源不放的同时，请求别的资源 循环等待条件： 存在一种进程资源的循环等待链 循环等待未必死锁，死锁一定有循环等待 什么时候会发生死锁：对不可剥夺资源的不合理分配，可能导致死锁 死锁的处理策略 避免死锁：破坏死锁产生的四个必要条件 避免死锁：避免系统进入不安全状态（银行家算法） 死锁的检测和解除：允许死锁发生，系统负责检测出死锁并解除 2. 死锁的处理策略——预防死锁 破坏互斥条件 将临界资源改造为可共享使用的资源（如SPOOLing技术） 缺点：可行性不高，很多时候无法破坏互斥条件 破坏不剥夺条件 方案一：申请的资源得不到满足时，立即释放拥有的所有资源 方案二：申请的资源被其他进程占用时，由操作系统协助剥夺（考虑优先级） 缺点： 实现复杂 剥夺资源可能导致部分工作失效 反复申请和释放导致系统开销大 可能导致饥饿 破坏请求和保持条件 运行前分配好所有需要的资源，之后一直保持 缺点：资源利用率低；可能导致饥饿 破坏循环等待条件 给资源编号，必须按编号从小到大的顺序申请资源 缺点： 不方便增加新设备 会导致资源浪费 用户编程麻烦 3. 动态策略——避免死锁 安全序列 不安全状态 银行家算法 4. 死锁的检测和解除 如何检测 数据结构：资源分配图 两种结点： 进程结点 资源结点 两种边： 进程结点—&gt;资源结点(请求边) 资源结点—&gt;进程结点(分配边) 死锁检测算法： 依次消除与不阻塞进程相连的边，直到无边可消 注：所谓不阻塞进程是指其申请的资源数还足够的进程 死锁定理：若资源分配图是不可完全简化的，说明发生了死锁 如何解除 资源剥夺法 撤销进程法(终止进程法) 进程回退法 三、内存管理(一)内存管理概念 1. 内存的基础知识 什么是内存，有何作用 存储单元、内存地址的概念和联系 按字节编址 vs 按字编址 进程运行的基本原理 指令的工作原理：操作码+若干参数(可能包含地址参数) 逻辑地址(相对地址) vs 物理地址(绝对地址) 从程序到程序运行 编辑源代码文件 编译：由源代码文件生成目标模块（高级语言翻译为机器语言） 链接：由目标模块生成装入模块，链接后形成完整的逻辑地址 装入：将装入模块装入内存，装入后形成物理地址 三种链接方式 静态链接：装入前链接成一个完整装入模块 装入时动态链接：运行前边装入边链接 运行时动态链接：运行时需要目标模块才装入并链接 三种装入方式 绝对装入：编译时产生绝对地址 可重定位装入(静态重定位)：装入时将逻辑地址转换为物理地址 动态运行时装入(动态重定位)：运行时将逻辑地址转换为物理地址，需设置重定位寄存器 2. 内存管理的概念 内存空间的分配与回收 内存空间的扩充（实现虚拟性） 覆盖技术 交换技术 虚拟存储技术 地址转换 操作系统负责实现逻辑地址到物理地址的转换 三种方式 绝对装入：编译器负责地址转换（单道程序阶段，无操作系统） 可重定位装入：装入程序负责地址转换（早期多道批处理系统） 动态运行时装入：运行时才进行地址转换（现代操作系统） 存储保护 保证各进程在自己的内存空间内运行，不会越界访问 两种方式 设置上下限寄存器 利用重定位寄存器、界地址寄存器进行判断 3. 覆盖与交换 覆盖技术 一个固定区 存放最活跃的程序段 固定区中的程序段在运行过程中不会调入调出 若干覆盖区 不可能同时被访问程序段可共享一个覆盖区 覆盖区中的程序段在运行过程中会根据需要调入调出 必须由程序员声明覆盖结构，操作系统完成自动覆盖 缺点：对用户不透明，增加了用户编程负担 交换技术 内存紧张时，换出某些进程以腾出内存空间，再换入某些进程 磁盘分为文件区和对换区，换出的进程放在对换区 覆盖与交换的区别 覆盖是在同一个程序或进程中的 交换是在不同进程（或作业）之间的 4. 连续分配管理方式 内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。 外部碎片：是指内存中的某些空闲分区由于太小而难以利用。 单一连续分配 只支持单道程序，内存分为系统区和用户区，用户程序放在用户区 无外部碎片，有内部碎片 固定分区分配 支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业 无外部碎片，有内部碎片 两种分区方式 分区大小相等 分区大小不等 动态分区分配 支持多道程序，在进程装入内存时，根据进程的大小动态建立分区 无内部碎片，有外部碎片 外部碎片可用“紧凑”技术来解决 回收内存分区时，可能遇到四种情况 回收区之后有相邻的空闲分区 回收区之前有相邻的空闲分区 回收区前、后都有相邻的空闲分区 回收区前、后都没有相邻的空闲分区 5. 动态分区分配算法 算法 算法思想 分区排列顺序 优点 缺点 首次适应 从头到尾找最适合的分区 空闲分区以地址递增次序排列 综合看性能最好。算法开销小，回收分区后一般不需要对空闲分区队列重新排序 最佳适应 优先使用更小的分区，以保留更多大分区 空闲分区以容量递增次序排列 会有更多的大分区被保留下来，更能满足大进程需求 会产生很多太小的、难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区队列重新排序 最坏适应 优先使用更大的分区，以防止产生太小的不可用的碎片 空闲分区以容量递减次序排列 可以减少难以利用的小碎片 大分区容易被用完，不利于大进程；算法开销大（原因同上） 临近适应 由首次适应演变而来，每次从上次查找结束位置开始查找 空闲分区以地址递增次序排列（可排列成循环链表） 不用每次都从低地址的小分区开始检索。算法开销小（原因同首次适应算法） 会使高地址的大分区也被用完 6. 基本分页存储管理的基本概念 基本分页存储管理的思想：把进程分页，各个页面可离散地放到各个的内存块中 重要概念： “页框、页帧、内存块、物理块” VS “页、页面” “页框号、页帧号、内存块号、物理块号” VS “页号、页面号” 如何实现地址转换 计算出逻辑地址对应的页号 找到对应页面在内存中的存放位置 算出逻辑地址对应的页内偏移量 物理地址=页面始址+页内偏移量 页号、页内偏移量的计算 页号=逻辑地址/页面大小 页内偏移量=逻辑地址%页面大小 或根据逻辑地址结构计算，逻辑地址=【页号P，页内偏移量W】 页表 页表记录进程页面和实际存放的内存块之间的对应关系 一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成 每个页表项的长度是相同的，页号是“隐含”的 7. 基本地址变换机构 页表寄存器的作用 存放页表起始地址 存放页表长度 地址变换过程 根据逻辑地址算出页号、页内偏移量 页号的合法性检查（与页表长度对比） 若页号合法，再根据页表起始地址、页号找到对应页表项 根据页表项中记录的内存块号、页内偏移量得到最终的物理地址 访问物理内存对应的内存单元 其他小细节 页内偏移量位数与页面大小之间的关系（要能用其中一个条件推出另一个条件） 页式管理中地址是一维的 实际应用中，通常使一个页框恰好能放入整个页表项 为了方便找到页表项，页表一般是放在连续的内存块中的 8. 具有快表的地址变换机构 地址变换过程： 算页号、页内偏移量 检查页号合法性 查快表。若命中，即可知道页面存放的内存块号，可直接进行5；若未命中则进行4 查页表，找到页面存放的内存块号，并将页表项复制到快表中 根据内存块号与页内偏移量得到物理地址 访问目标内存单元 访问一个逻辑地址的访存次数 快表命中，只需一次访存 快表未命中，需要两次访存 9. 两级页表 单级页表存在的问题 所有页表项必须连续存放，页表过大时需要很大的连续空间 在一段时间内并非所有的页面都用得到，因此没必要让整个页表常驻内存 两级页表 将长长的页表再分页 逻辑地址结构：【一级页号，二级页号，页内偏移量】 注意几个术语：页目录表/外层页表/顶级页表 如何实现地址转换 按照地址结构将逻辑地址拆分成三部分 从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置 根据二级页号查表，找到最终想访问的内存块号 结合页内偏移量得到物理地址 几个细节 多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级 多级页表的访存次数（假设没有快表机构）：N级页表访问一个逻辑地址需要N+1次访存 10. 基本分段存储管理方式 分段 将地址空间按照程序自身的逻辑关系划分为若干个段，每段从0开始编址 每个段在内存中占据连续空间，但各段之间可以不相邻 逻辑地址结构：【段号，段内地址】 段表 记录逻辑段到实际存储地址的映射关系 每个段对应一个段表项。各段表项长度相同，由段号(隐含)、段长、基址组成 地址变换 由逻辑地址得到段号、段内地址 段号与段表寄存器中的段长度比较，检查是否越界 由段表始址、段号找到对应段表项 根据段表中记录的段长，检查段内地址是否越界 由段表中的“基址+段内地址”得到最终的物理地址 访问目标单元 分段VS分页 分页对用户不可见，分段对用户可见 分页的地址空间是一维的，分段的地址空间是二维的 分段更容易实现信息的共享和保护（纯代码/可重入代码可以共享） 分页（单级页表）、分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构 11. 段页式管理方式 分段+分页 将地址空间按照程序自身的逻辑关系划分为若干个段，再将各段分为大小相等的页面 将内存空间分为与页面大小相等的一个个内存块，系统以块为单位为进程分配内存 逻辑地址结构：【段号，页号，页内偏移量】 段表、页表 每个段对应一个段表项。各段表项长度相同，由段号（隐含）、页表长度、页表存放地址组成 每个页对应一个页表项。各页表项长度相同，由页号（隐含）、页面存放的内存块号组成 地址变换 由逻辑地址得到段号、页号、页内偏移量 段号与段表寄存器中的段长度比较，检查是否越界 由段表始址、段号找到对应段表项 根据段表中记录的页表长度，检查页号是否越界 由段表中的页表地址、页号得到查询页表，找到相应页表项 由页面存放的内存块号、页内偏移量得到最终的物理地址 访问目标单元 访问一个逻辑地址所需访存次数 第一次查段表、第二次查页表、第三次访问目标单元 可引入快表机构，以段号和页号为关键字查询快表，即可直接找到最终的目标页面存放位置。引入快表后仅需一次访存 (二)虚拟内存管理 1. 虚拟内存的基本概念 传统存储管理方式的特征、缺点 一次性：作业数据必须一次全部调入内存 驻留性：作业数据再整个运行期间都会常驻内存 局部性原理 时间局部性：现在访问的指令、数据在不久后很可能会被再次访问 空间局部性：现在访问的内存单元周围的内存空间，很可能在不久后被访问 高速缓存技术：使用频繁的数据放到更高速的存储器中 虚拟内存的定义和特征 定义：程序不需要全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需换出一些数据 特征： 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存 对换性：无需在作业运行时一直常驻内存，而是允许在作业运行过程中，将作业换入、换出 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量 如何实现虚拟内存技术 访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存（请求调页功能） 内存空间不够时，将内存中暂时不用的信息换出到外存（页面置换功能） 虚拟内存的实现 请求分页存储管理 请求分段存储管理 请求段页式存储管理 2. 请求分页管理方式 页表机制 在基本分页的基础上增加了几个表项 状态位：表示页面是否已在内存中 访问字段：记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出时参考 修改位：表示页面调入内存后是否被修改过，只有修改过的页面才需在置换时写回外存 外存地址：页面在外村中存放的位置 缺页中断机构 找到页表项后检查页面是否已在内存，若没在内存，产生缺页中断 缺页中断处理中，需要将目标页面调入内存，有必要时还要换出页面 缺页中断属于内中断，属于内中断中的“故障”，即可能被系统修复的异常 一条指令在执行过程中可能产生多次缺页中断 地址变换机构 找到页表项时需要检查页面是否在内存中 若页面不在内存中，需要请求调页 若内存空间不够，还需换出页面 页面调入内存后，需要修改相应页表项 3. 页面置换算法 算法名 算法规则 优缺点 OPT 优先淘汰最长时间内不会被访问的页面 缺页率最小，性能最好；但无法实现 FIFO 优先淘汰最先进入内存的页面 实现简单；但性能很差，可能出现Belady异常 LRU 优先淘汰最近最久没访问的页面 性能很好；但需要硬件支持，算法开销大 CLOCK（NRU） 循环扫描各页面，第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第一轮没选中，则进行第二轮扫描。 实现简单，算法开销小；但未考虑页面是否被修改过 改进型CLOCK 若用【访问位，修改位】的形式表述，则：第一轮：淘汰【0，0】第二轮：淘汰【0，1】，并将扫描过的页面访问位都置为0第三轮：淘汰【0，0】第四轮：淘汰【0，1】 算法开销较小，性能也不错 4. 页面分配策略 页面分配、置换策略 固定分配VS可变分配：区别在于进程运行期间驻留集大小是否可变 局部置换VS全局置换：区别在于发生缺页时是否只能从进程自己的页面中选择一个换出 固定分配局部置换：进程运行前就分配一定数量的物理块，缺页时只能换出进程自己的某一页 可变分配全局置换：只要缺页就分配新物理块，可能来自空闲物理块，也可能需换出别的进程页面 可变分配局部置换：频繁缺页的进程，多分配一些物理块；缺页率很低的进程，回收一些物理块。直到缺页率合适 何时调入页面 预调页策略：一般用于进程运行前 请求调页策略：进程运行时，发现缺页再调页 从何处调页 对换区：采用连续存储方式，速度更快 文件区：采用离散存储方式，速度更慢 对换区足够大：运行将数据从文件区复制到对换区，之后所有的页面调入、调出都是在内存与对换区之间进行 对换区不够大：不会修改的数据每次都从文件区调入；会修改的数据调出到对换区，需要时再从对换区调入 UNIX方式：第一次使用的页面都从文件区调入；调出的页面都写回对换区，再次使用时从对换区调入 抖动（颠簸）现象：页面频繁换入换出的现象。主要原因是分配给进程的物理块不够 驻留集：指请求分页管理中给进程分配的内存块的集合 工作集：在某段时间间隔里，进程实际访问页面的集合。驻留集大小一般不能小于工作集大小 四、文件管理(一)文件系统1. 初识文件管理 文件的定义：一组有意义的信息的集合 文件的属性：文件名、标识符、类型、位置、大小、保护信息… 文件内部应该如何被组织起来（文件的逻辑结构） 文件之间应该如何被组织起来（目录结构） 操作系统应向上提供哪些功能（create、delete、open、close、read、write系统调用） 文件应如何存放在外存中（文件的物理结构） 操作系统如何管理外存中的空闲块（存储空间的管理） 操作系统需要提供的其他文件管理功能 文件共享 文件保护 2. 文件的逻辑结构 顺序文件 串结构：记录顺序与关键字无关 顺序结构：记录按关键字顺序排列 可变长记录的顺序文件无法实现随机存取，定长记录可以 定长记录、顺序结构的顺序文件可以快速检索（根据关键字快速找到记录） 最大缺点：不方便增加/删除记录 索引文件 建立一张索引表，每个记录对应一个表项。各记录不用保持顺序，方便增加/删除记录 索引表本身就是定长记录的顺序文件，一个索引表项就是一条定长记录，因此索引文件可支持随机存取 若索引按关键字排序，则可支持快速检索 解决了顺序文件不方便增/删记录的问题，同时让不定长记录的文件实现了随机存取。但索引表可能占用很多空间 索引顺序文件 将记录分组，每组对应一个索引表项 检索记录时先顺序查索引表，找到分组，再顺序查找分组 当记录过多时，可建立多级索引表 3. 文件目录 文件目录的实现 一个文件对应一个FCB，一个FCB就是一个目录项，多个FCB组成文件目录 对目录的操作：搜索、创建文件、删除文件、显示文件、修改文件 目录结构 单级目录结构：一个系统只有一张目录表，不允许文件重名 两级目录结构：不同用户的文件可以重名，但不能对文件进行分类 多级（树形）目录结构： 不同目录下的文件可以重名，可以对文件进行分类，不方便文件共享 系统根据文件路径找到目标文件 从根目录出发的路径是绝对路径 从当前目录出发的路径是相对路径 无环图目录结构 在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录变成一个有向无环图 为共享节点设置一个共享计数器，计数器为0时才真正删除该节点 索引节点 除了文件名之外的所有信息都放到索引节点中，每个文件对应一个索引节点 目录项中只包含文件名、索引节点指针，因此每个目录项的长度大幅减小 由于目录项长度减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时磁盘I/O的次数就少了很多 4. 文件的物理结构（文件的分配方式） 分配方式 How？ 目录项内容 优点 缺点 顺序方式 为文件分配的必须是连续的磁盘块 起始块号、文件长度 顺序存取速度快，支持随机访问 会产生碎片，不利于文件扩展 隐式链接分配 除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针 起始块号、结束块号 可解决碎片问题，外存利用率高，文件扩展实现方便 只能顺序访问，不能随机访问 显式链接分配 建立一张文件分配表（FAT），显式记录盘块的先后关系（开机后FAT常驻内存） 起始块号 除了拥有隐式链接的优点之外，还可以通过查询内存中的FAT实现随机访问 FAT需要占用一定的存储空间 索引分配 为文件数据块建立索引表。若文件太大，可采用链接方案、多层索引、混合索引 链接方案记录的是第一个索引块的块号，多层/混合索引记录的是顶级索引块的块号 支持随机访问，易于实现文件的扩展 索引表需占用一定的存储空间。访问数据块前需要先读入索引块。若采用链接方案，查找索引块时可能需要很多次读磁盘操作。 5. 文件存储空间管理 存储空间的划分与初始化 文件卷（逻辑卷），目录区、文件区的概念 目录区包含文件目录、空闲表、位示图、超级块等用于文件管理的数据 空闲表法 空闲表中记录每个连续空闲区的起始盘块号、盘块数 分配时可采用首次适应、最佳适应策略；回收时注意表项的合并问题 空闲链表法 空闲盘块链 以盘块为单位组成一条空闲链 分配时从链头依次取出空闲块，回收时将空闲块插到链尾 空闲盘区链 以盘区为单位组成一条空闲链 分配时可采用首次适应、最佳适应等策略；回收时注意相邻空闲盘区合并的问题 位示图法 一个二进制位对应一个盘块。【字号，位号】或【行号，列号】与盘块号一一对应 重要考点：要能够自己推出盘块号-&gt;【字号，位号】之间的相互转换公式 需要注意的题目条件 二进制位0/1到底哪个代表空闲，哪个代表不空闲 字号、位号、盘块号到底是从0开始还是从1开始 成组链接法：UNIX采用的策略，适合大型文件系统。 6. 文件的基本操作 创建文件：分配外存空间，创建目录项 删除文件：回收外存空间，删除目录项 打开文件 将目录项中的信息复制到内存中的打开文件表中，并将打开文件表的索引号返回给用户（打开文件时并不会把文件数据直接读入内存。“索引号”也称“文件描述符”） 打开文件之后，对文件的操作不再需要每次都查询目录，可以根据内存中的打开文件表进行操作 每个进程都有自己的打开文件表，系统中也有一张总的打开文件表 进程打开文件表中特有的属性：读写指针、访问权限（只读？读写？） 系统打开文件表中特有的属性：打开计数器（有多少个进程打开了该文件） 关闭文件 将进程打开文件表中的相应表项删除 读文件 写文件 7. 文件共享8. 文件保护9. 文件系统的层次结构(二)磁盘组织与管理五、输入输出（IO）管理(一)IO管理概述(二)IO核心子系统]]></content>
      <categories>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[概率论面试常问问题总结]]></title>
    <url>%2F2020%2F07%2F21%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[给你一副52张扑克牌发给4个人，其中一个人同时拿到红桃A和黑桃A的概率是多少？ 首先选定一个人拿红桃A和黑桃A，即$C_4^1=4$ 然后这个人从剩下的50张牌里拿11张(每人13张牌)，即$C_{50}^{11}$ 然后剩下的三个人每人从牌堆里拿13张，就是$ C{39}^{13}C{26}^{13}C_{13}^{13} $ 四个人每人13张牌的情况总数为：$ C{52}^{13}C{39}^{13}C{26}^{13}C{13}^{13} $ 所以最终的概率为： \frac{C_{4}^{1}C_{50}^{11}C_{39}^{13}C_{26}^{13}C_{13}^{13}}{C_{52}^{13}C_{39}^{13}C_{26}^{13}C_{13}^{13}}=\frac{C_{4}^{1}C_{50}^{11}}{C_{52}^{13}}=\frac{4\frac{50!}{39!11!}}{\frac{52!}{39!13!}}=\frac{4}{17} 有一个苹果，两个人抛硬币来决定谁吃这个苹果，先抛到正面的人吃，问先抛的人吃到苹果的概率是多少？ 显然先抛硬币的人能吃到的苹果的情况是： 第1次为正面； 第1次是反面，第2次是反面，第3次是正面； 第1次是反面，第2次是反面，第3次是反面，第4次是反面，第5次是正面； 依此类推…可以得到概率是: P=\frac{1}{2}+\frac{1}{8}+\frac{1}{32}+...\frac{1}{2}·(\frac{1}{4})^{n-1}+...=\sum_{n=1}^{\infty}\frac{1}{2}·(\frac{1}{4})^{n-1}=\frac{2}{3} 这里还有一种比较巧妙的递归思路： 给所有的抛硬币操作从1开始编号，显然先手只能在奇数(1,3,5,7…)次抛硬币得到苹果，而后手只可能在偶数次(2,4,6,8…)抛硬币得到苹果； 假设先手得到苹果的概率为p，第一次抛硬币得到苹果的概率是$\frac{1}{2}$； 在第3次及以后得到苹果的概率是$\frac{p}{4}$，这是这种情况只有在第1次和第2次抛硬币都没有抛到正面(概率为$\frac{1}{2}\times\frac{1}{2}=\frac{1}{4}$)的时候才发生，而此时先手在此面临和开始相同的局面； 所以可以列出等式：$p=\frac{1}{2}+\frac{p}{4}$，解出来$p=\frac{2}{3}$]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[97.交错字符串]]></title>
    <url>%2F2020%2F07%2F18%2F97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。 1234567示例 1:输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;输出: true示例 2:输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;输出: false 题解思路这道题动态规划其实挺难想的，但是如果想通了就感觉很简单。定义dp[i][j]代表s1的前i个元素和s2的前j个元素是否能交错组成s3的i+j个元素。如果s1的第i个元素和s3的第i+j个元素相等，那么s1的前i个元素和s2的前j个元素是否能交错组成s3的i+j个元素取决于s1的前i-1个元素和s2的前j个元素是否能交错组成s3的i+j-1个元素，也就是说当s1[i-1]==s3[i+j-1]时，dp[i][j]=dp[i-1][j]，同理可得，当s2[j-1]==s3[i+j-1]时，dp[i][j]=dp[i][j-1]，所以状态转移方程如下： dp(i,j)= \left\{\begin{matrix} dp(i-1, j),(s1[i-1]=s3[i+j-1])\\ dp(i, j-1),(s2[j-1]=s3[i+j-1])\\ false,others \end{matrix}\right.可以简化写成： dp[i][j]=(dp[i-1][j] \&\& (s1[i-1]==s3[i+j-1])) || (dp[i][j-1] \&\& (s2[j-1]==s3[i+j-1]))同时要注意一下边界值，当i=0时，拿s2和s3单独比较，如果s2[j]!=s3[j]时，就把dp[0][j+1]以及后面的都置为false，当j=0时候同理。很显然我们可以得出dp[0][0]是true。 代码123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; //定义一个二维数组，初始化为false。 auto dp = vector&lt; vector&lt;bool&gt; &gt;(s1.size()+1, vector&lt;bool&gt;(s2.size()+1, false)); int len1=s1.length(), len2=s2.length(), len3=s3.length(); if(len1+len2!=len3) return false; //dp数组初始化 dp[0][0]=true; for(int i=1;i&lt;=len1;i++)&#123; if(s1[i-1]==s3[i-1]) dp[i][0]=dp[i-1][0]; else break; &#125; for(int i=1;i&lt;=len2;i++)&#123; if(s2[i-1]==s3[i-1]) dp[0][i]=dp[0][i-1]; else break; &#125; //状态转移 for(int i=1;i&lt;=len1;i++)&#123; for(int j=1;j&lt;=len2;j++)&#123; dp[i][j]=(dp[i-1][j] &amp;&amp; (s1[i-1]==s3[i+j-1])) || (dp[i][j-1] &amp;&amp; (s2[j-1]==s3[i+j-1])); &#125; &#125; return dp[len1][len2]; &#125;&#125;; 滚动数组优化空间因为dp[i][j]仅仅依赖于dp[i-1][j]或者dp[i][j-1]，也就是dp数组只依赖于自身和上一行的值，所以可以使用滚动数组来优化空间复杂度。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; //定义一个二维数组，初始化为false。 int len1=s1.length(), len2=s2.length(), len3=s3.length(); auto dp = vector&lt;bool&gt;(len3+1, false); if(len1+len2!=len3) return false; dp[0]=true; if(len2==0) &#123; for(int i=1;i&lt;=len1;i++)&#123; if(s1[i-1]==s3[i-1]) dp[i]=dp[i-1]; else break; &#125; return dp[len1]; &#125; //dp数组初始化 for(int j=1;j&lt;=len2;j++)&#123; if(s2[j-1]==s3[j-1]) dp[j]=dp[j-1]; else break; &#125; //状态转移 for(int i=1;i&lt;=len1;i++)&#123; for(int j=0;j&lt;=len2;j++)&#123; dp[j]= dp[j] &amp;&amp; (s1[i-1]==s3[i+j-1]); if(j&gt;0) dp[j]=dp[j] || (dp[j-1] &amp;&amp; (s2[j-1]==s3[i+j-1])); &#125; &#125; return dp[len2]; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>滚动数组优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[96.不同的二叉搜索树]]></title>
    <url>%2F2020%2F07%2F16%2F96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目链接96.不同的二叉搜索树 题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 1234567891011示例:输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路动态规划思路给定一个有序序列 $1…n$，为了构建一棵二叉搜索树，我们可以遍历每个数字 $i$，把该数字作为树根，将 $1…(i-1)$序列作为左子树， $(i+1)…n$序列作为右子树，然后我们可以用递归的方式来构建左子树和右子树。 于是原问题就被划分成了两个子问题，所以可以用动态规划的方法来求解，定义两个函数： $G(n):长度为n的序列能构成不同二叉搜索树的个数$ $F(i,n):以i为根，长度为n的序列能构成不同二叉搜索树的个数(1\leqslant i \leqslant n)$ 于是， $G(n)$就是我们求解需要的函数，我们可以发现，这两个函数是有关系的： G(n)=\sum_{i=1}^{n}F(i,n) \\ F(i,n)=G(i-1)\times G(n-i)所以我们可以推出： G(n)=\sum_{i=1}^{n}G(i-1)G(n-i)这样我们只要从前往后把 $G(n)$一点一点算出来就行，因为 $G(n)$的值依赖于 $G(0)···G(n-1)$ 。在这之前我们需要确定边界值，当序列长度为1（只有根）或为0（空树）时，只有一种情况，所以不难得出： G(0)=0\\ G(1)=1代码123456789101112131415class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; G(n + 1, 0); G[0] = 1; G[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; G[i] += G[j - 1] * G[i - j]; &#125; &#125; return G[n]; &#125;&#125;; 数学方法：卡特兰数思路上面已经推出了 $G(n)$的一种递推公式，其实还可以推出另一种递推公式来，这里就不去推了，直接给出来： C_{n+1}=\frac{2(2n+1)}{n+2}C_n代码12345678910class Solution &#123;public: int numTrees(int n) &#123; long long C = 1; for (int i = 0; i &lt; n; ++i) &#123; C = C * 2 * (2 * i + 1) / (i + 2); &#125; return (int)C; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[785.判断二分图]]></title>
    <url>%2F2020%2F07%2F16%2F785-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[题目链接785.判断二分图 题目描述给定一个无向图graph，当这个图为二分图时返回true。 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。 graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。 12345678910示例 1:输入: [[1,3], [0,2], [1,3], [0,2]]输出: true解释: 无向图如下:0----1| || |3----2我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。 12345678910示例 2:输入: [[1,2,3], [0,2], [0,1,3], [0,2]]输出: false解释: 无向图如下:0----1| \ || \ |3----2我们不能将节点分割成两个独立的子集。 注意: graph 的长度范围为 [1, 100]。 graph[i] 中的元素的范围为 [0, graph.length - 1]。 graph[i] 不会包含 i 或者有重复的值。 图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。 解题思路什么是二分图二分图也叫二部图。对于图中的任意两个节点u和v，如果他们之间有一条边相连，那么u和v必须属于不同的集合。并且只能有两个集合，如果两个相连的点在同一个集合，就不是二分图。 如何判断二分图判断这个图是否是二分图，我们可以对其节点进行染色操作，最后根据染色的结果来判断是否是二分图。 我们可以任选一个节点开始，将起染成红色，然后遍历与其相连的节点，把他们都染成绿色，再把和这些绿色节点相邻的点染成红色，以此类推，直到所有的节点都被染色。 如果我们染色成功，则红色节点和绿色节点分属两个集合，这个无向图就是个二分图；如果我们不能成功染色，就是说在染色过程中遇到了一个已经染色的节点，假设它是红色的，但我们现在要把它染成绿色，这就发生了矛盾，就无法继续染色了，说明这个图就不是二分图。 算法流程 任选一个节点，将其染成红色，并从该节点开始对整个无向图进行遍历； 在遍历的过程中，如果我们通过节点 u 遍历到了节点 v（即 u 和 v 在图中有一条边直接相连），那么会有两种情况： 如果 v 未被染色，那么我们将其染成与 u 不同的颜色，并对 v 直接相连的节点进行遍历； 如果 v 被染色，并且颜色与 u 相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回 False作为答案。 当遍历结束时，说明给定的无向图是二分图，返回 True 作为答案； 可以使用DFS或者BFS对无向图进行遍历。 注意题目中给定的无向图不一定保证连通，因此我们需要进行多次遍历，直到每一个节点都被染色，或确定答案为False 为止。每次遍历开始时，我们任选一个未被染色的节点，将所有与该节点直接或间接相连的节点进行染色。 代码dfs123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;private: static constexpr int UNCOLORED = 0; static constexpr int RED = 1; static constexpr int GREEN = 2; vector&lt;int&gt; color; //记录节点涂色的情况 bool flag; //记录是否是二分图public: void dfs(int node, int c, vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; color[node]=c; if(!flag) return; int nextColor=(c==RED?GREEN:RED); for(int neighbour:graph[node]) &#123; if(color[neighbour]==UNCOLORED)&#123; dfs(neighbour, nextColor, graph); &#125; else if(color[neighbour]!=nextColor)&#123; flag = false; return; &#125; &#125; &#125; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int n=graph.size(); color.assign(n,UNCOLORED);//先把图中每个点初始化为未涂色 flag = true; for(int i=0;i&lt;n;i++)&#123; if(color[i]==UNCOLORED)&#123; dfs(i, RED, graph); &#125; &#125; return flag; &#125;&#125;; bfs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;private: static constexpr int UNCOLORED = 0; static constexpr int RED = 1; static constexpr int GREEN = 2; vector&lt;int&gt; color; //记录节点涂色的情况 bool flag; //记录是否是二分图public: bool bfs(int node, int c, vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; queue&lt;int&gt;Q; Q.push(node); color[node]=c; while(!Q.empty()) &#123; int front=Q.front(); Q.pop(); int nextColor=(color[front]==RED?GREEN:RED); for(int neighbor:graph[front]) &#123; if(color[neighbor]==UNCOLORED) &#123; color[neighbor]=nextColor; Q.push(neighbor); &#125; else if(color[neighbor]!=nextColor) return false; &#125; &#125; return true; &#125; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int n=graph.size(); color.assign(n,UNCOLORED);//先把图中每个点初始化为未涂色 flag = true; for(int i=0;i&lt;n;i++)&#123; if(color[i]==UNCOLORED)&#123; flag = bfs(i, RED, graph); if(!flag) return flag; &#125; &#125; return true; &#125;&#125;; ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>二分图</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机启动的过程]]></title>
    <url>%2F2020%2F07%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分法边界值问题总结]]></title>
    <url>%2F2020%2F07%2F02%2F%E4%BA%8C%E5%88%86%E6%B3%95%E8%BE%B9%E7%95%8C%E5%80%BC%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[二分法边界值问题总结一、结论先说结论，二分边界值一般有两种正确的写法： 第一种写法，二分的区间左闭右开，[left, right)： 123456789101112int left=0,right=nums.size();//right取不到int mid=0;while(left&lt;right)//这里是小于号&#123; mid=left+(right-left)/2;//一般都这么写，防止left+right溢出 if(nums[mid]==target) return mid; if(nums[mid]&lt;target) left=mid+1; else right=mid;//注意&#125; 第二种写法，二分的区间左右都是闭的，[left, right]： 123456789101112int left=0,right=nums.size()-1;//right能取到int mid=0;while(left&lt;=right)//这里是小于等于&#123; mid=left+(right-left)/2; if(nums[mid]==target) return mid; if(nums[mid]&lt;target) left=mid+1; else right=mid-1;//注意&#125; 二、原理]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux服务器的screen简单使用]]></title>
    <url>%2F2019%2F10%2F09%2Flinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84screen%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[远程连接服务器时，当你断开ssh窗口，当前的操作也会终止，这时候需要用到screen来保持当前窗口在后台运行。 Screen 常用指令 screen -S yourname -&gt; 新建一个叫yourname的sessionscreen -ls -&gt; 列出当前所有的sessionscreen -r yourname -&gt; 回到yourname这个sessionscreen -d yourname -&gt; 远程detach某个sessionscreen -X -S yourname -&gt; 关闭这个session Screen 常用操作 Ctrl-a d -&gt; detach，暂时离开当前session 关于Screen详细解析点此]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用快捷键&命令]]></title>
    <url>%2F2019%2F07%2F21%2F%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%26%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[[TOC] mac常用快捷键一、系统快捷键 组合键 功能 Command Q 关闭当前软件 Command W 关闭当前窗口 Command M 当前窗口最小化 Command H 隐藏当前窗口 Command C 复制 Command Option V 剪切 Command Control Q 锁屏 Command Control F 全屏 Command Shift . 显示/隐藏 隐藏文件 Control Option T 打开终端 Command shift 5 截屏/录屏 Command shift 3 保存截屏(全屏)到桌面 Command control shift 3 复制截屏(全屏)到剪切板 Command shift 4 保存截屏(所选区域)到桌面 Command control shift 4 复制截屏(所选区域)到剪切板 Control Shift X 使用Keka解压 Control Shift C 使用Keka压缩 Control 右方向键 切换到下一个窗口 Command Option 空格 打开访达搜索 Command Shift O 前往文稿 Command Shift D 前往桌面 Command Option L 前往下载 Command I 显示简介 Command L 定位查单词 Command Control 空格 调出emoji表情 暂无快捷键，控制颜色 § 二、QQ 组合键 功能 Command Control A 截屏 Command Control R 录屏 Command Control G 打开搜索框 Command Control Z 打开未读消息 Command Control O 识别屏幕文字 三、Chrome 组合键 功能 Command Shift N 打开新的无痕窗口 Command Shift T 重新打开关闭的标签页 Command Shift B 隐藏/显示书签栏 Command Shift W 关闭当前窗口 Control Shift Tab 切换到上一个标签页 Control Tab 切换到下一个标签页 Command R 刷新该页面 Command N 打开新的窗口 Command T 新建标签页 Command W 关闭当前标签页 四、Typora 组合键 功能 Command Shift Delete 删除当前行 Command / 切换源码模式 五、Sublime Text 组合键 功能 Control Shift K 删除当前行 Command Shift D 复制当前行并粘贴 六、IntelliJ IDEA 快捷键 功能 Option F7 可以获得当前类的子类等信息，相当于右键类名，然后选择“Find Usages” Control Option O 删除无用的包的import Control O 插入@Override的方法 七、PyCharm 快捷键 功能 Command Y 删除光标所在行 Command 右方向键 跳到行尾 Command 左方向键 跳到行首 Windows常用快捷键一、系统 组合键 功能 win L 锁屏 win S 搜索 Linux &amp; MacOS 常用指令一、系统 命令 功能 uptime 显示运行时间 kill -9 &lt;进程号&gt; 强制杀死该进程 lsof -i:&lt;端口号&gt; 查看该端口的详细信息 ssh user@host 远程连接 sudo shutdown -h now 立刻关机 sudo shutdown -r now 立刻重启 二、screen 命令 功能 screen -S SESSION 创建一个新的会话 screen -ls 列出当前所有的session screen -r SESSION 回到SESSION这个会话 screen -d SESSION detach这个session screen -X -S SESSION quit 杀死SESSION]]></content>
      <tags>
        <tag>macos</tag>
        <tag>linux</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft开服教程]]></title>
    <url>%2F2019%2F07%2F02%2FMinecraft%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[几点说明 本篇为我的世界服务端搭建的教程，简单来说就是教你如何开服，与小伙伴在同一个世界里玩耍。 当然，如果你的服务端搭建在远程vps上就可以远程联机，如果服务端只是在你本地运行的话那只有和你同属局域网的人才能联机。 Spigot 纯净服务端搭建我本人并不推荐官方的服务端，不能安装插件，优化也不怎么样，可以说，Spigot/Bukkit 是当前最稳定高效的纯净服务端了，并且其有强大的社区，各种各样的插件，可玩性是相当的高。下面就来说说该如何搭建 spigot 1.12.2 服务端。 首先要下载 spigot 1.12.2 服务端核心。这个服务端核心在官网是找不到的，你只能下载到构建工具，点此直接下载服务端核心 百度网盘提取码:cw2g。 新建一个文件夹，就取名叫 server 吧，然后把刚才下载的spigot-1.12.2.jar文件丢进去。 在 server 文件夹内新建一个文件，将其改名为 run.bat，用编辑器打开，复制这一段代码进去并保存： 12Java -jar -Xms1G -Xmx2G spigot-1.12.2.jar noguiPAUSE 其实这是个windows批处理文件，之后你双击这个文件就相当于在命令行输入了这些语句，这样开服就方便些，不需要每次都输命令那么麻烦。简单解释一下这些参数的含义吧： Java -jar 是指用java运行这个jar包，也就是后面那个spigot-1.12.2，就是服务端的核心； -Xms1G 运行服务器的最小内存，这里给了1G； -Xmx2G 运行服务器的最大内存，这里给了2G，当然你可以根据实际情况修改； nogui 指不启用gui，因为你服务端本来就没有gui； PAUSE 这行让你在关闭服务器之后不会立刻关闭命令行。 双击 run.bat 文件，会自动跳出了命令行，然后报错，这时关闭命令行，你会发现 server 文件夹里多出来一些东西，这时打开 eula.txt ,将 eula=false 改成 eula=true ，表示你同意mojang的eula协定。 再次双击 run.bat 文件，等待它生成一些配置文件和加载世界结束后，服务器就能正常运行了。 但这还没有结束，你会发现如果不用正版账号根本进不去服务器。所以要用编辑器打开 server.properties ，找到 online-mode=true 这一行，将其改为 online-mode=false ，意思就是关闭在线模式，这样用离线模式就能登录服务器了。 现在服务器已经搭建成功，接下来你要知道你的服务器地址，打开命令行，输入 ipconfig ，回车，查看你的ipv4地址，复制，然后打开游戏客户端，进入多人游戏，点击 添加服务器 按钮，在服务器地址框里粘贴刚才复制的ip，在后面加上端口号25565，中间要加上冒号”:”，这里要注意一定是英文的冒号，如果是中文冒号客户端就找不到服务器，之后点击 完成 按钮。 一切就绪，现在点击加入服务器按钮就可以进入游戏，同时你可以将服务器地址和端口号告诉别人和你一起联机，前提是要在一个内网下，不过一般高校的校园网内都是能联机的。]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft 1.12.2 Mod Tutorial 01 搭建开发环境]]></title>
    <url>%2F2019%2F06%2F26%2FMinecraft-1-12-2-Mod-Tutorial-01-%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一、安装Java既然要写mod，那么java必不可少，首先我们就来安装jdk (java development kit)。jdk可以去官网下载。下载完毕后一路下一步即可安装。 二、安装IntelliJ IDEA这里更推荐用IDEA来进行mod开发，原因就是非常好用并且IDEA有关于mc开发的插件。同样给出下载链接Intellij IDEA 官网下载。社区版即可，如果有教育邮箱可以免费使用付费版本，下载后按照流程安装即可。 三、搭建mod开发环境1.下载mdkmdk可以直接去Forge官网下载推荐的稳定版本Mdk 1.12.2-14.23.5.2768 2.解压mdk将下载好的Mdk解压到你的工程目录，然后我们用编辑器打开build.gradle文件，在最下面加上下面一段代码，目的是将构建的编码改为UTF-8。123tasks.withType(JavaCompile)&#123; options.encoding = "UTF-8"&#125; 其他部分改不改都无所谓，不过你也可以自己研究研究这个文件的其他部分。 3.构建环境在当前目录打开命令行，输入这个命令1gradlew setupDecompWorkspace idea 接下来就是漫长的等待，当出现 build successful 就是构建成功了。 4.在IDEA中运行项目]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Mod</tag>
        <tag>Forge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[minecraft常用指令]]></title>
    <url>%2F2019%2F01%2F17%2Fminecraft%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[/gamerule mobGriefing false 关闭爆炸破坏方块 /gamerule doFireTick false 关闭火势蔓延 /gamerule keepInventory true 开启死亡不掉落 /difficulty 0 调整难度，0为和平，1为简单，2为普通，3为困难 /spawnpoint [玩家] 设置玩家的出生点为脚下 /setworldspawn 设置全服玩家的出生点为脚下]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python知识点小结]]></title>
    <url>%2F2018%2F10%2F10%2Fpython%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[[TOC] 49. 字典 核心底层原理 内存分析 查找值对象过程字典用法总结： 键必须可散列。 数字、字符串、元组，都是可散列的 自定义对象需要支持下面三点： 支持hash()函数 支持通过__eq__()的方法检测相等性 若a==b为真，则hash(a)==hash(b)也为真 字典在内存中开销巨大，典型的空间换时间。 键查询速度很快。 往字典里面添加新键可能导致扩容，导致散列表中键的次序变化。因此，不要在遍历字典的同时进行字典的修改。 50. 集合 特点 创建和删除 交并差运算 集合的特点 集合无序可变，元素不能重复。实际上，集合底层是字典实现，集合的所有元素都是字典中的“键对象”，因此是不能重复且唯一的。 集合的创建和删除 使用{}创建集合对象，并使用add()方法添加元素 使用set()，将列表、元组等可迭代对象转成集合。如果原来数据存在重复数据，则只保留一个 remove()删除指定元素； clear()整个集合 集合相关操作 并：a|b 或 a.union(b) 交：a&amp;b 或 a.intersection(b) 差：a-b 或 a.difference(b)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java命名规范]]></title>
    <url>%2F2018%2F08%2F01%2FJava%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[类名命名规范 类名应该采用大写驼峰式（Upper Camel Case），大写驼峰式指的是每个单词只有首字母大写，然后把它们直接拼合起来，比如 immersiveEngineering 等。 对于缩写单词，所有字母全部大写或者只有首字母大写往往都可以，比如FMLTutor和FmlTutor都是可以的。 方法和字段的命名惯例 小写驼峰式（Lower Camel Case），小写驼峰式指的是只有第一个单词全部小写，第二个开始的单词的所有字母中只有首字母大写，然后把它们直接拼合起来，比如getRegistryName方法等。 全大写加下画线（Upper Snake Case），即将所有字母大写，然后单词之间使用下画线分隔。 在通常情况下，Java规定，只有同时被 final和 static两个修饰符修饰的字段，即不可变静态字段，才应该使用全大写加下画线的命名风格命名，而在其他情况下的方法和字段都应该使用小写驼峰命名。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印全排列]]></title>
    <url>%2F2018%2F07%2F21%2F%E6%89%93%E5%8D%B0%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入n，代表有n个数，然后输入这n个数，要求打印出这n个数的全排列。 思路全排列问题就是递归和回溯的思想。这里有两种思路： 不改变原数组所谓不改变原数组，就是从原数组中n个数中挑选n个数排起来。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000;int a[maxn];int n;int out[maxn];int vis[maxn];//n个数全排列，排到了第m个void dfs(int m)&#123; if(m==n+1)//选到了第n+1个，说明选完了 &#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;out[i]&lt;&lt;' '; cout&lt;&lt;endl; return; &#125; //一个一个数看是否用过 for(int i=1;i&lt;=n;i++) &#123; if(!vis[i]) &#123; out[m]=a[i];//第m个数是a[i] vis[i]=1;//标记一下选过 dfs(m+1);//排第m+1个数 vis[i]=0;//回溯 &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); dfs(1);//从第一个数开始排 &#125; return 0;&#125; 改变原数组在原数组的基础上调换顺序，生成全排列序列，每次选一个数和后面的数依次交换，形成全排列。注意这种方法无法字典序输出全排列。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000;int a[maxn];int n;//n个数全排列，排到了第m个void dfs(int m)&#123; if(m==n) &#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;' '; cout&lt;&lt;endl; return; &#125; //从当前数开始和后面的数交换 for(int i=m;i&lt;=n;i++) &#123; swap(a[m], a[i]); dfs(m+1); swap(a[m], a[i]); &#125;&#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); dfs(1);//从第一个数开始排 &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印组合数]]></title>
    <url>%2F2018%2F07%2F21%2F%E6%89%93%E5%8D%B0%E7%BB%84%E5%90%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述首先给你一个 n (n&gt;0) 和 k (0&lt;k&lt;n)。 然后给你 n个没有重复的整数，数字间用空格分开。你需要输出这些数字的$C_n^k$种组合。 组合中的元素用空格分开，末尾无多余空格。组合内部的数字由小到大排列。不同的组合由小到大排列。具体见案例。 样例输入 5 2 1 2 3 4 5 样例输出 1 21 31 41 52 32 42 53 43 54 5 题解和全排列比较像，也是递归和回溯。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000;int a[maxn];int n,k;int out[maxn];int vis[maxn];//n个数选k个数，选到了第m个，并且上一个是第lastStartIndexvoid dfs(int m, int lastStartIndex)&#123; if(m==k+1)//选到了第k+1个，说明选完了 &#123; for(int i=1;i&lt;=k;i++) cout&lt;&lt;out[i]&lt;&lt;' '; cout&lt;&lt;endl; return; &#125; //因为是组合问题，不能重复，所以从上次选的位置的下一个开始 for(int i=lastStartIndex;i&lt;=n;i++) &#123; if(!vis[i]) &#123; out[m]=a[i];//第m个数是a[i] vis[i]=1;//标记一下选过 dfs(m+1, i+1);//从当前下一个位置开始选第m+1个数 vis[i]=0;//回溯 &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;k) &#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); dfs(1, 1);//从第一个数开始选第一个数 &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用算法模板整理]]></title>
    <url>%2F2018%2F07%2F21%2F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[[TOC] 数据结构1. 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# include&lt;iostream&gt;using namespace std;int a[100];int n;void quick_sort(int left, int right)&#123; if(left&gt;=right) return; int i=left, j=right; int tmp=a[left]; //基准数 while(i!=j) &#123; // 顺序很重要，必须先从右往左找 while(i&lt;j &amp;&amp; a[j]&gt;=tmp) j--; // 再从左往右找 while(i&lt;j &amp;&amp; a[i]&lt;=tmp) i++; // 交换两个数在数组中的位置 if(i&lt;j) &#123; int t = a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; //最终将基准数归位 a[left]=a[i]; a[i]=tmp; quick_sort(left,i-1); quick_sort(i+1, right);&#125;int main()&#123; while(cin&gt;&gt;n &amp;&amp; n) &#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; quick_sort(1,n); for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;' '; cout&lt;&lt;endl; &#125; return 0;&#125; 使用stl的排序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n;struct STU&#123; char name[110]; int age; int score; bool operator &lt; (const STU &amp;b)const&#123;//C++的运算符重载 if(score!=b.score) return score&lt;b.score; else&#123; int tmp=strcmp(name, b.name); if(tmp!=0) return tmp&lt;0; else return age&lt;b.age; &#125; &#125;&#125;stu[1005];bool cmp(STU a, STU b)&#123; if(a.score!=b.score) return a.score&lt;b.score; else&#123; int tmp=strcmp(a.name, b.name); if(tmp!=0) return tmp&lt;0; else return a.age&lt;b.age; &#125;&#125;int main()&#123; while(scanf("%d", &amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;stu[i].name&gt;&gt;stu[i].age&gt;&gt;stu[i].score; &#125; //sort(stu+1, stu+n+1, cmp); sort(stu+1, stu+n+1); for(int i=1;i&lt;=n;i++) &#123; cout&lt;&lt;stu[i].name&lt;&lt;' '&lt;&lt;stu[i].age&lt;&lt;' '&lt;&lt;stu[i].score&lt;&lt;endl; &#125; &#125; return 0;&#125;/*3abc 20 99bcd 19 97bed 20 97*/ 2.链表2.1创建链表创建一个有n个结点的链表，此代码未释放空间，危险 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;struct node&#123; int data; struct node *next;&#125;;int main()&#123; struct node *head, *p, *q, *t; int i,n,a; cin&gt;&gt;n; head = NULL; // 头指针初始为空 for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a; // 动态申请要一个空间，用来存放一个结点，并用临时指针p指向这个结点 p=(struct node *)malloc(sizeof(struct node)); p-&gt;data=a; p-&gt;next=NULL; if(head==NULL) //如果这是第一个创建的结点，则头指针指向这个结点 head=p; else //如果不是第一个创建的结点，则将上一个节点的后继指针指向当前结点 q-&gt;next=p; q=p;//指针q也指向当前结点 &#125; //输出链表中的所有数 t=head; while(t!=NULL) &#123; cout&lt;&lt;t-&gt;data&lt;&lt;' '; t=t-&gt;next; &#125; return 0;&#125; 2.2链表反转先对原链表做头删操作，再对新链表做头插 1234567891011121314struct ListNode *reverseList(struct ListNode* head) &#123; struct ListNode *newHead = NULL; struct ListNode *node; while (head != NULL) &#123; //1. 对之前的链表做头删 node = head; head = head-&gt;next; //2. 对新链表做头插 node-&gt;next = newHead; newHead = node; &#125; return newHead;&#125; 3.DFS3.1 dfs模板123456789101112void dfs(int step)&#123; // 1.判断边界 // 2.尝试每一种可能 for(int i=1;i&lt;=n;i++) &#123; // 3.继续下一步 dfs(step+1); &#125; // 4.返回 return;&#125; 3.2 全排列123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n;int book[11];int a[11];void dfs(int step)&#123;// step表示现在站在第几个盒子面前 if(step==n+1) &#123;//如果站在第n+1个盒子面前，则表示前n个盒子已经放好扑克牌 for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]; cout&lt;&lt;endl; return; &#125; for(int i=1;i&lt;=n;i++) &#123; if(book[i]==0) &#123; book[i]=1; a[step]=i; dfs(step+1); book[i]=0; // 回溯，很关键 &#125; &#125; return;&#125;int main()&#123; while(cin&gt;&gt;n &amp;&amp; n) &#123; memset(book,0,sizeof(book)); dfs(1); //首先站在1号小盒子面前 &#125; return 0;&#125; 4. 树1. 并查集1234567891011int find(int x)&#123; return parent[x] == x ? x : find(parent[x]);&#125;void to_union(int x1, int x2) &#123; int p1 = find(x1); int p2 = find(x2); parent[p1] = p2;&#125; 图论1.最短路1.1 Floyd-Warshall求解任意两点间的最短路，$O(n^3)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;int e[10][10],n,m;int inf=99999999;void init()//初始化&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i==j) e[i][j]=0; else e[i][j]=inf;&#125;void floyd()//Floyd-Warshall算法核心语句&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(e[i][k]&lt;inf &amp;&amp; e[k][j]&lt;inf &amp;&amp; e[i][j]&gt;e[i][k]+e[k][j]) e[i][j]=e[i][k]+e[k][j];&#125;int main()&#123; int t1,t2,t3; cin&gt;&gt;n&gt;&gt;m; init(); for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3; e[t1][t2]=t3; &#125; floyd(); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf("%10d", e[i][j]); cout&lt;&lt;endl; &#125; return 0;&#125; 1.2 Dijkstra算法求解固定点(此代码为一号顶点)到其他点的最短路，$O(n^2)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;int e[10][10],dis[10],book[10];int n; // 顶点数量int m; // 边数量int point; // 起点int inf = 99999999;void init()//初始化&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i==j) e[i][j]=0; else e[i][j]=inf;&#125;void Dijkstra()&#123; for(int i=1;i&lt;=n;i++) dis[i]=e[point][i]; for(int i=1;i&lt;=n;i++) book[i]=0; book[point]=1; //核心语句 for(int i=1;i&lt;=n-1;i++) &#123; //找到离point号顶点最近的顶点 int minn=inf; int u=0; for(int j=1;j&lt;=n;j++) &#123; if(book[j]==0 &amp;&amp; dis[j]&lt;minn) &#123; minn=dis[j]; u=j; &#125; &#125; book[u]=1; for(int v=1;v&lt;=n;v++) &#123; if(e[u][v]&lt;inf) if(dis[v]&gt;dis[u]+e[u][v]) dis[v]=dis[u]+e[u][v]; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;point; init(); int t1,t2,t3; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3; e[t1][t2]=t3; &#125; Dijkstra(); for(int i=1;i&lt;=n;i++) cout&lt;&lt;dis[i]&lt;&lt;' '; cout&lt;&lt;endl; return 0;&#125;/*6 9 11 2 11 3 122 3 92 4 33 5 54 3 44 5 134 6 155 6 4*/ 1.3 Bellman-Ford（TODO）字符串1.马拉车（求最长回文字串）12345678910111213141516171819202122232425262728293031323334353637//C++代码//返回源字符串S的最长回文子串 string Manacher(string s)&#123; //预处理源串 string t = "$#"; for(int i=0; i&lt;s.size(); i++)&#123; t+=s[i]; t+="#"; &#125; //新建p数组,大小和t串一致，初始化为0 ，p[i]表示以t[i]为中心的回文串半径 vector&lt;int&gt; p(t.size() , 0); //设定重要参数 mx(某回文串延伸到的最右边下标),id(mx所属回文串中心下标), //reCenter（结果最大回文串中心下标）,reLen（最大长回文长度） int mx = 0, id = 0, reCenter = 0, reLen = 0; //遍历t字符串 for(int i=1; i&lt;t.size(); i++)&#123; //核心算法 p[i] = mx &gt; i ? min(mx - i , p[2*id - i]) : 1; //上面的语句只能确定i~mx的回文情况，至于mx之后的部分是否对称，就只能老老实实去匹配了，匹配一个p[i]++ while(t[i + p[i]] == t[i - p[i]]) p[i]++; //当t[i]匹配的 右边界超过mx时mx和id就更新 if(i+p[i] &gt; mx)&#123; mx = i+p[i]; id = i; &#125; //更新结果数据 if(p[i] &gt; reLen)&#123; reLen = p[i]; reCenter = i; &#125; &#125; return s.substr((reCenter - reLen) / 2 , reLen - 1) ; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Java代码public String preProcess(String s) &#123; int n = s.length(); if (n == 0) &#123; return "^$"; &#125; String ret = "^"; for (int i = 0; i &lt; n; i++) ret += "#" + s.charAt(i); ret += "#$"; return ret;&#125;// 马拉车算法public String longestPalindrome(String s) &#123; String T = preProcess(s); int n = T.length(); int[] P = new int[n]; int C = 0, R = 0; for (int i = 1; i &lt; n - 1; i++) &#123; int i_mirror = 2 * C - i; if (R &gt; i) &#123; P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R &#125; else &#123; P[i] = 0;// 等于 R 的情况 &#125; // 碰到之前讲的三种情况时候，需要利用中心扩展法 while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) &#123; P[i]++; &#125; // 判断是否需要更新 R if (i + P[i] &gt; R) &#123; C = i; R = i + P[i]; &#125; &#125; // 找出 P 的最大值 int maxLen = 0; int centerIndex = 0; for (int i = 1; i &lt; n - 1; i++) &#123; if (P[i] &gt; maxLen) &#123; maxLen = P[i]; centerIndex = i; &#125; &#125; int start = (centerIndex - maxLen) / 2; //最开始讲的求原字符串下标 return s.substring(start, start + maxLen);&#125; 数学1. 快速幂12345678910111213141516171819202122232425262728typedef long long LL;//递归实现LL mod_pow(LL x, LL n, LL mod)&#123; if(n==0) return 1; LL res=mod_pow(x*x%mod,n/2,mod); if(n&amp;1) res=res*x%mod; return res;&#125;//迭代实现LL pow_mod(LL a, LL n, LL p)&#123; LL ret = 1; LL tmp = a; while(n) &#123; if(n &amp; 1) ret = (ret * tmp) % p; tmp = tmp * tmp % p; n &gt;&gt;= 1; &#125; return ret;&#125;//时间复杂度：O(log n) 2.线性素数筛1234567891011121314151617181920bool judge[maxn];int prime[maxn/10];int n; //素数表中的素数都小于n；int nprime; //素数个数；void doprime(int n) //线性筛法；&#123; //生成n以下的素数表(prime[1]=2,prime[2]=3)； memset(judge,true,sizeof(judge)); judge[1]=judge[0]=0; for(int i=2;i&lt;n;i++) &#123; if(judge[i]) prime[++nprime]=i; for(int j=1;j&lt;=nprime&amp;&amp;i*prime[j]&lt;n;j++) &#123; judge[i*prime[j]]=0; if(i%prime[j]==0) break; &#125; &#125;&#125; 动态规划1.背包问题1.1 0-1背包1234567891011121314151617181920212223242526272829/*一维版本*/int dp[MAX_W+1]; //dp数组int v[n+1]; //价值数组int w[n+1]; //重量数组void solve()&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=W;j&gt;=w[i];j--)&#123; dp[j]=max(dp[j], dp[j-w[i]]+v[i]); &#125; &#125; printf("%d\n", dp[W]);&#125;/*二维版本*/int dp[MAX_N+1][MAX_W+1];void solve()&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;=W;j++)&#123; if(j&lt;w[i]) dp[i+1][j]=dp[i][j]; else dp[i+1][j]=max(dp[i][j], dp[i][j-w[i]]+v[i]); &#125; &#125; printf("%d\n", dp[n][W]);&#125; 1.2 完全背包1234567891011121314151617181920212223242526/*一维版本*/int dp[MAX_W+1];void solve()&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=w[i];j&lt;=W;j--)&#123; dp[j]=max(dp[j], dp[j-w[i]]+v[i]); &#125; &#125; printf("%d\n", dp[W]);&#125;/*二维版本*/int dp[MAX_N+1][MAX_W+1];void solve()&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;=W;j++)&#123; if(j&lt;w[i]) dp[i+1][j]=dp[i][j]; else dp[i+1][j]=max(dp[i][j], dp[i+1][j-w[i]]+v[i]); &#125; &#125; printf("%d\n", dp[n][W]);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[memset的用法浅谈]]></title>
    <url>%2F2018%2F07%2F17%2Fmemset%E7%9A%84%E7%94%A8%E6%B3%95%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[简介memset()是用来给一块空间批量赋值的函数，经常用来给数组初始化为0或者-1，但是不能初始化为1，为什么下面会讲到。 描述C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 头文件#include&lt;cstring&gt; 参数 str — 指向要填充的内存块。 c — 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。 n — 要被设置为该值的字节数。 用法123456789101112int a[100];//把一个数组赋值为全0memset(a, 0, sizeof(a));//把一个数组赋值为全-1memset(a, -1, sizeof(a));//注意这样并不能把一个数组赋值为全1memset(a, 1, sizeof(a));//sizeof(a)是获取a的字节数，而不是元素个数，如果是int数组就是4:1的关系。 注意要注意 memset()这个函数是按字节初始化的，比如这里的memset(a, 1, sizeof(a));他是把整数1(0x00000001)的最后一个字节赋值给a这个数组的所有字节，所以a数组的每个元素的值变成了0x01010101，这个数的十进制形式显然不是1。 那么为什么-1和0就可以正常赋值呢，那是因为-1(0xffffffff)和0(0x00000000)的每个字节都是一样的，所以换句话说，只要一个整数每个字节都是一样的，就可以用memset()来批量赋值，比如0x3f3f3f3f、0x7f7f7f7f等。]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>memset</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
