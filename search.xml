<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[337.打家劫舍III]]></title>
    <url>%2F2020%2F08%2F05%2F337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII%2F</url>
    <content type="text"><![CDATA[题目链接337.打家劫舍III 题目描述在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 样例1234567891011示例1:输入: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 1234567891011示例2:输入: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 解题思路从题目描述中我们大概可以猜到这是一个动态规划的题，但是这是在树上的动归，可以用深搜的方法来解决。我们可以定义两个数组： f[o]代表选中当前节点的最大值 g[o]代表不选当前节点的最大值 那么我们可以得到转移方程就是： f[o] = o-&gt;val + g[o-&gt;left] + g[o-&gt;right] 因为不能偷两家相邻的节点，所以如果偷了当前节点，就不能偷他的左右儿子节点 g[o] = max(f[o-&gt;left], g[o-&gt;left]) + max(f[o-&gt;right], g[o-&gt;right]) 如果不偷当前这家，就可以偷他的左右儿子，但也可以不偷，选择更优的的结果。 代码12345678910111213141516171819class Solution &#123;public: unordered_map&lt;TreeNode*, int&gt; f,g; int rob(TreeNode* root) &#123; dfs(root); return max(f[root], g[root]); &#125; void dfs(TreeNode* o) &#123; if(!o) return; dfs(o-&gt;left); dfs(o-&gt;right); f[o]=o-&gt;val+g[o-&gt;left]+g[o-&gt;right]; g[o]=max(f[o-&gt;left], g[o-&gt;left])+max(f[o-&gt;right], g[o-&gt;right]); &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[207.课程表]]></title>
    <url>%2F2020%2F08%2F04%2F207-%E8%AF%BE%E7%A8%8B%E8%A1%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[887.鸡蛋掉落]]></title>
    <url>%2F2020%2F07%2F30%2F887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[343.整数拆分]]></title>
    <url>%2F2020%2F07%2F30%2F343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[计网复习重点]]></title>
    <url>%2F2020%2F07%2F28%2F%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[一、计算机网络体系结构（一）计算机网络概述1. 概念、组成、功能和分类 概念：计算机网络是互连的、自治的计算机集合 组成 组成部分：硬件、软件、协议 工作方式：边缘部分、核心部分 功能组成：通信子网、资源子网 功能 数据通信 资源共享 分布式处理、提高可靠性、负载均衡 分类 分布范围：广域网、城域网、局域网、个人区域网 使用者：公用网、专用网 交换技术：电路交换、报文交换、分组交换 拓扑结构：总线型、星型、环型、网状型 传输技术：广播式、点对点 2. 性能指标 速度相关 速率：实际速率 带宽：理论最大最大速率 吞吐量 时间相关 时延 传输时延（主机内部到信道） 传播时延（电磁波在信道中传输） 时延带宽积：传播时延$\times$ 带宽 往返时延RTT：传播时延$\times$2 利用率：利用率越高，网络越拥堵 信道利用率：$\frac{有数据通过时间}{(有+无)数据通过时间}$ 网络利用率：信道利用率加权平均值 （二）计算机网络体系结构与参考模型二、物理层（一）通信基础（二）传输介质（三）物理层设备三、数据链路层（一）（二）四、网络层五、传输层六、应用层]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[410.分割数组的最大值]]></title>
    <url>%2F2020%2F07%2F26%2F410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[1025.除数博弈]]></title>
    <url>%2F2020%2F07%2F24%2F1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统复习重点]]></title>
    <url>%2F2020%2F07%2F23%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[一、操作系统概述 1. 操作系统的概念、功能和目标 概念（定义） 操作系统控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机系统的工作和资源的分配，以提供给用户和其他软件方便的借口和环境，它是计算机系统中最基本的 系统软件。 功能 资源的管理者 处理机管理 存储器管理 文件管理 设备管理 向用户提供服务 命令接口（用户直接使用） 联机命令接口：命令行式 脱机命令接口：批处理式 程序接口：即“系统调用”，又叫“广义指令”，用户通过程序间接使用 GUI（图形用户界面） 对硬件机器的扩展：扩充机器 目标：方便用户使用 2. 操作系统的特征 并发（与共享互为存在条件） 共享：即资源共享 互斥共享方式（如对摄像头设备的共享使用） 同时共享方式（如对硬盘资源的共享使用） 虚拟 空分复用技术（如虚拟存储技术） 时分复用技术（如虚拟处理器技术） 异步异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是程序的异步性。 显然，如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。只有系统拥有并发性，才可能导致异步性。 3. 操作系统的发展与分类 手工操作系统阶段 缺点：人机速度矛盾 批处理阶段 单道批处理系统（引入脱机输入输出技术） 优点：缓解人机速度矛盾 缺点：资源利用率依然很低 多道批处理系统（操作系统开始出现） 优点：多道程序并发执行，资源利用率高 缺点：不提供人机交互功能 分时操作系统 优点：提供人机交互功能 缺点：不能优先处理紧急任务 实时操作系统 硬实时操作系统（必须在绝对严格的规定时间内完成处理） 软实时操作系统（能接受偶尔违反时间规定） 优点：能优先处理紧急任务 网络操作系统 分布式操作系统 个人计算机操作系统 4. OS的运行机制和体系结构 运行机制 两种指令 特权指令（不允许用户程序使用）：如内存清零指令 非特权指令：如普通的运算指令 两种处理器状态 核心态（管态） 用户态（目态）用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为核心态。 用户态到核心态是通过 中断 实现的，并且中断是唯一途径。 核心态到用户态的切换是通过 执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”。 两种程序 内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。 应用程序：为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。 操作系统内核 时钟管理：实现计时功能 中断管理：负责实现中断机制 原语 是一种特殊的程序 处于操作系统最底层，是最接近硬件的部分 这种程序的运行具有原子性，只能一气呵成，不可中断 运行时间较短、调用频繁 对系统资源进行管理的功能 进程管理 存储器管理 设备管理 操作系统的体系结构 大内核 将操作系统的主要功能模块都作为系统内核，运行在核心态 优点：高性能 缺点：内核代码庞大，结构混乱，难以维护 微内核 只把基本的功能保留在内核 优点：内核功能少，结构清晰，方便维护 缺点：需要繁琐地在核心和用户态之间切换，性能低 5. 中断和异常 中断机制的诞生：为了实现多道程序并发执行而引入的一种技术 中断的概念和作用 发生中断，就意味着操作系统介入开展管理工作，CPU会立即进入核心态 “中断”是CPU从用户态进入核心态的唯一路径 中断的分类 内中断（也称为异常、例外、陷入，信号来源于CPU内部，与当前执行的指令有关） 自愿中断——指令中断：如系统调用时使用的访管指令（又叫陷入指令、trap指令） 强迫中断 硬件故障：如缺页 软件中断：如整数除0 外中断（也叫中断，信号来源于CPU外部，与当前执行的指令无关） 外设请求：如I/O操作完成发生的中断信号 人工干预：如用户强行终止一个进程 另一种分类方式： 内中断（内部异常） 陷进、陷入（trap）：有意而为之的异常，如系统调用 故障（fault）：由错误条件引起的，可能被故障处理程序修复，如缺页 终止（abort）：不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除0 外中断 I/O中断请求 人工干预 外中断的处理过程 每条指令执行结束后，CPU检查是否有外部中断信号 若有外部中断信号，则需要保护被中断进程的CPU环境（PSW，PC，通用寄存器） 根据中断信号类型转入相应的中断处理程序 恢复原进程的CPU环境并退出中断，返回原进程继续往下执行 6. 系统调用 什么是系统调用，有何作用？ 操作系统提供给应用程序使用的接口 应用程序通过系统调用来请求获得操作系统的服务 系统调用会使处理器从用户态进入核心态 分类： 设备管理 文件管理 进程控制 进程通信 内存管理 凡是与资源有关的操作、会直接影响到其他进程的操作，一定需要操作系统介入，即需要通过系统调用来实现。 系统调用和库函数的区别 系统调用时操作系统向上层提供的接口 有的库函数是对系统调用的进一步封装 当今编写的应用程序大多数是通过高级语言提供的库函数间接地进行系统调用 系统调用背后的过程 传递系统调用参数 执行陷入指令（唯一一条只能在用户态执行，而不能在核心态执行的指令） 执行系统调用相应服务程序 返回用户程序 注意 系统调用发生在 用户态，对系统调用的处理发生在 核心态。 执行陷入指令会产生内中断，使处理器从用户态进入核心态。 陷入指令又叫trap指令、访管指令 二、进程管理（一）进程与线程 1. 进程的定义、组成、组织方式、特征 定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位 组成： PCB 进程描述信息 进程控制和管理信息 资源分配清单 处理机相关信息 程序段：存放要执行的程序代码 代码段：存放程序运行过程中处理的各种数据 组织形式： 链接方式：按进程状态将PCB分为多个队列 索引方式：按照进程状态建立几张索引表，各表指向一个PCB 特征： 动态性：进程的最基本特征 并发性 独立性：进程是系统进行资源分配、调度的独立单位 异步性：各进程以不可预知的速度向前推进，可能导致运行结果的不确定性 结构性 2. 进程的状态与转换 状态 运行状态：有CPU，有其他所需资源 就绪状态：无CPU，有其他所需资源 阻塞状态：无CPU，无其他所需资源 创建状态：操作系统为新进程分配资源、创建PCB 终止状态：操作系统回收进程的资源、撤销PCB 进程状态间的转换 就绪态—&gt;运行态：进程被调度 运行态—&gt;就绪态：时间片到，或CPU被其他高优先级的进程抢占 运行态—&gt;阻塞态：等待系统资源分配，或等待某事件发生（主动行为） 阻塞态—&gt;就绪态：资源分配到位，等待的事件发生（被动行为） 创建态—&gt;就绪态：系统完成创建进程相关的工作 运行态—&gt;终止态：进程运行结束，或运行过程中遇到不可修复的错误 3. 进程控制 基本概念 进程控制就是要实现进程状态的转换 进程控制用原语实现 原语用关/开中断来实现 原语是一种特殊的程序 原语的执行必须一气呵成，不可中断 相关原语 进程的创建 进程的终止 进程的阻塞 进程的唤醒 进程的切换 4. 进程通信 共享存储 设置一个共享空间 要互斥地访问共享空间 两种方式 基于数据结构（低级） 基于存储区的共享（高级） 消息传递 传递结构化的消息（消息头/消息体） 系统提供“发送/接受原语” 两种方式： 直接通信方式：消息直接挂到接收进程的消息缓冲队列上 间接通信方式：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式” 管道通信 设置一个特殊的共享文件（管道），其实就是一个缓冲区 一个管道只能实现半双工通信 实现双向同时通信要建立两个管道 各进程要互斥访问管道 写满时，不能再写。读空时，不能再读 没写满，不能读。没读空，不能写 5. 线程概念和多线程模型 什么是线程，为什么要引入线程？ 可理解为“轻量级进程” 可增加并发度，减少并发带来的开销 引入线程机制后，有什么变化？（和传统的进程机制对比） 资源分配、处理机调度 并发性 （实现并发的）系统开销 线程有哪些重要的属性 线程是处理机调度的单位，进程是资源分配的单位 同一进程的各线程共享进程拥有的资源 同一进程内的线程切换不会导致进程切换 线程的实现方式 用户级线程：从用户视角看的线程 内核级线程：从操作系统视角看的进程（内核级线程才是处理机分配的单位） 组合方式：上述两种方式的结合 多线程模型 多对一模型 优点：进程管理开销小效率高 缺点：一个线程阻塞会导致整个进程都被阻塞（并发度低） 一对一模型 优点：各个线程可分配到多核处理机并行执行，并发度高 缺点：进程管理开销大 多对多模型：集二者之所长 （二）处理机调度 1. 处理机调度 基本概念：按某种算法选择一个进程将处理机分配给它 三个层次： 高级调度（作业调度）：按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 中级调度（内存调度）：按照某种规则，从挂起队列中选择合适的进程将其数据调回内存 低级调度（进程调度）：按照某种规则，从就绪队列中选择一个进程为其分配处理机 三层调度的联系、对比 高级调度： 外存—&gt;内存（面向作业） 发生频率：最低 中级调度： 外存—&gt;内存（面向进程） 发生频率：中等 低级调度： 内存—&gt;CPU 发生频率：最高 补充知识 为减轻系统负载，提高资源利用率，暂时不进行的进程会被调到外存而变成“挂起态” 七状态模型：在五状态模型的基础上加入了“就绪挂起”和“阻塞挂起”两种状态 2. 进程调度 进程调度的时机 什么时候需要进程调度？ 主动放弃： 进程正常终止 运行过程中发生异常而终止 主动阻塞（如 等待IO） 被动放弃： 分给进程的时间片用完 有更紧急的事情需要处理（如IO中断） 有更高优先级的进程进入就绪队列 什么时候不能进行进程调度？ 在处理中断的过程中 进程在操作系统内核程序临界区中（进程处于普通临界区中是可以调度的） 原子操作过程中（原语） 进程切换与过程 狭义的“调度”和“切换”的区别 切换过程 对原来运行进程各种数据的保存 对新的进程各种数据的恢复 重要结论：进程调度、切换时有代价的，并不是调度越频繁，并发度就越高 进程调度的方式 非剥夺调度方式（非抢占式）：只能由当前运行的进程主动放弃CPU 剥夺调度方式（抢占式）：可由操作系统剥夺当前进程的CPU使用权 3. 调度算法的评价指标 CPU利用率 利用率=\frac{忙碌时间}{总时间} 系统吞吐量 系统吞吐量=\frac{总共完成了多少道作业}{总共花了多少时间} 周转时间 周转时间 = 作业完成时间-作业提交时间 \\ 平均周转时间 = \frac{各作业周转时间之和}{作业数} \\ 带权周转时间 = \frac{作业周转时间}{作业实际运行时间} \\ 平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数} 等待时间 进程或作业等待被服务的时间之和 平均等待时间即各个进程或作业等待时间的平均值 响应时间：从用户提交请求到首次产生响应所用的时间 4. 调度算法（适用于批处理系统） 算法 可抢占 优点 缺点 考虑等待时间or运行时间？ 是否会导致饥饿？ FCFS 非抢占式 公平；实现简单 对短作业不利 等待时间 不会 SJF/SPF 默认为非抢占式，也有SJF的抢占式版本最短剩余时间优先算法（SRTN） “最短的”平均等待and周转时间 对长作业不利，可能导致饥饿；难以做到正真的短作业优先 运行时间 会 HRRN 非抢占式 上述两种算法的权衡折中，综合考虑的等待时间和运行时间 等待时间和运行时间 不会 注意：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。 5. 调度算法（适用于交互式系统） 时间片轮转（RR，Round-Robin） 算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。 用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片） 是否可抢占？如进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。有时钟装置发出时钟中断来通知CPU时间片已到 优缺点 公平；响应快，适用于分时操作系统； 缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度 是否会导致饥饿？不会 补充：时间片太大，退化为先来先服务；时间片太小，切换进程开销大。 优先级调度算法 多级反馈队列调度算法 总结： 算法 可抢占？ 优点 缺点 会导致饥饿？ 补充 时间片轮转 抢占式 公平，适用于分时系统 频繁切换有开销，不区分优先级 不会 时间片太大或太小有何影响？ 优先级调度 有抢占式也有非抢占式的 区分优先级，适用于实时系统 可能会导致饥饿 会 动态/静态优先级。各类进程如何设置优先级？如何调整优先级？ 多级反馈队列 抢占式 平衡优秀 一般不说它有缺点，不过可能导致饥饿 会 注意：比起早起的批处理系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适用于交互式系统（比如UNIX使用的就是多级反馈队列调度算法）。 （三）进程同步 1. 同步、互斥 进程同步 并发性带来了异步性，有时需要通过进程同步解决这种异步的问题 有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的先后顺序 进程互斥 对临界资源的访问，需要互斥的进行。即同一时间段内只能允许一个进程访问该资源 四个部分 进入区：检查是否可以进入临界区，若可进入，需要“上锁” 临界区：访问临界资源的那段代码 退出区：负责“解锁” 剩余区：其余代码部分 需要遵循的原则 空闲让进：临界区空闲时，应允许一个进程访问 忙则等待：临界区正在被访问时，其他试图访问的进程需要等待 有限等待：要在有限时间内进入临界区，保证不会饥饿 让权等待：进不了临界区的进程，要释放处理机，防止忙等 2. 进程互斥的软件实现方法 单标志法 在进入区只做“检查”，不“上锁” 在退出区把临界资源的使用权转交给另一个进程（相当于在退出区既给另一进程“解锁”，又给自己“上锁”） 主要问题：不遵循“空闲让进”原则 双标志先检查 在进入区先“检查”后“上锁”，退出区“解锁” 主要问题：不遵循“忙则等待”原则 双标志后检查 在进入区先“加锁”后”检查“，退出区“解锁” 主要问题：不遵循“空闲让进、有限等待”原则，可能导致“饥饿” Peterson算法 在进入区“主动争取——主动谦让——检查对方是否想进——己方是否谦让” 主要问题：不遵循“让权等待”原则，会发生“忙等” 3. 进程互斥的硬件实现方法 中断屏蔽方法 使用开关中断指令实现 优点：简单高效 缺点：只适用于单处理机；只适用于操作系统内核进程 TestAndSet(TS指令/TSL指令) 步骤： old记录是否已被上锁 再将lock设为true 检查临界区是否已被上锁（若已上锁，则循环重复前几步） 优点：实现简单；适用于多处理机环境； 缺点：不满足“让权等待” Swap指令（XCHG指令）：逻辑上同TSL 4. 信号量机制 整型信号量 用一个整数型变量作为信号量，数值表示某种资源数 整型信号量与普通整型变量的区别：对信号量只能执行 初始化、P、V三种操作 整型信号量存在的问题：不满足让权等待原则 记录型信号量 S.value表示某种资源数，S.L指向等待该资源的队列 P操作中，一定是先S.value—，之后可能需要执行block原语 V操作中，一定是先S.value++，之后可能需要执行wakeup原语 注意：要能够自己腿短在什么条件下需要执行block或wakeup 可以用记录型信号量实现系统资源的“申请”和“释放” 可以用记录型信号量实现进程互斥、进程同步 5. 用信号量实现进程互斥、同步 实现进程互斥 分析问题，确定临界区 设置互斥信号量，初值为1 临界区之前对信号量执行P操作 临界区之后对信号量执行V操作 实现进程同步 分析问题，找出哪里需要实现“一前一后”的同步关系 设置同步信号量，初始值为0 在“前操作”之后执行V操作 在“后操作”之前执行P操作 实现进程的前驱关系 分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题 为每一对前驱关系设置同步信号量，初值为0 在每个“前操作”之后执行V操作 在每个“后操作”之前执行P操作 6. 信号量相关问题 生产者-消费者问题 多生产者-多消费者问题 吸烟者问题 读者-写者问题：计数器count 哲学家进餐问题 注意：同步信号量的P操作一定在互斥信号量的P操作之前 7. 管程（与类的封装特性相似） 为什么要引入管程：解决信号量机制编程麻烦、易出错的问题 组成 共享数据结构 对数据结构初始化的语句 一组用来访问数据结构的过程（函数） 基本特征 各外部进程/线程只能通过管程提供的特定“入口”才能访问共享数据 每次仅允许一个进程在管程内执行某个内部过程 补充 各进程必须互斥访问管程的特性是由编译器实现的 可在管程中设置条件变量及等待/唤醒操作以解决同步问题 （四）死锁1. 死锁的概念 什么是死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进 进程死锁、饥饿、死循环的区别 死锁：至少是两个进程一起死锁，死锁进程处于阻塞状态 饥饿：可以只有一个进程饥饿，饥饿进程可能阻塞也可能就绪 死循环：可能只有一个进程发生死循环，死循环的进程可上处理机 死锁和饥饿是操作系统要解决的问题，死循环是应用程序员要解决的 死锁产生的必要条件 互斥条件：对必须互斥使用的资源的争抢才会导致死锁 不可剥夺条件：进程保持的资源只能主动释放，不可强行剥夺 请求和保持条件：保持着某些资源不放的同时，请求别的资源 循环等待条件： 存在一种进程资源的循环等待链 循环等待未必死锁，死锁一定有循环等待 什么时候会发生死锁：对不可剥夺资源的不合理分配，可能导致死锁 死锁的处理策略 避免死锁：破坏死锁产生的四个必要条件 避免死锁：避免系统进入不安全状态（银行家算法） 死锁的检测和解除：允许死锁发生，系统负责检测出死锁并解除 三、内存管理四、文件管理五、输入输出（IO）管理]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论面试常问问题总结]]></title>
    <url>%2F2020%2F07%2F21%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[给你一副52张扑克牌发给4个人，其中一个人同时拿到红桃A和黑桃A的概率是多少？ 首先选定一个人拿红桃A和黑桃A，即$C_4^1=4$ 然后这个人从剩下的50张牌里拿11张(每人13张牌)，即$C_{50}^{11}$ 然后剩下的三个人每人从牌堆里拿13张，就是$ C{39}^{13}C{26}^{13}C_{13}^{13} $ 四个人每人13张牌的情况总数为：$ C{52}^{13}C{39}^{13}C{26}^{13}C{13}^{13} $ 所以最终的概率为： \frac{C_{4}^{1}C_{50}^{11}C_{39}^{13}C_{26}^{13}C_{13}^{13}}{C_{52}^{13}C_{39}^{13}C_{26}^{13}C_{13}^{13}}=\frac{C_{4}^{1}C_{50}^{11}}{C_{52}^{13}}=\frac{4\frac{50!}{39!11!}}{\frac{52!}{39!13!}}=\frac{4}{17} 有一个苹果，两个人抛硬币来决定谁吃这个苹果，先抛到正面的人吃，问先抛的人吃到苹果的概率是多少？ 显然先抛硬币的人能吃到的苹果的情况是： 第1次为正面； 第1次是反面，第2次是反面，第3次是正面； 第1次是反面，第2次是反面，第3次是反面，第4次是反面，第5次是正面； 依此类推…可以得到概率是: P=\frac{1}{2}+\frac{1}{8}+\frac{1}{32}+...\frac{1}{2}·(\frac{1}{4})^{n-1}+...=\sum_{n=1}^{\infty}\frac{1}{2}·(\frac{1}{4})^{n-1}=\frac{2}{3} 这里还有一种比较巧妙的递归思路： 给所有的抛硬币操作从1开始编号，显然先手只能在奇数(1,3,5,7…)次抛硬币得到苹果，而后手只可能在偶数次(2,4,6,8…)抛硬币得到苹果； 假设先手得到苹果的概率为p，第一次抛硬币得到苹果的概率是$\frac{1}{2}$； 在第3次及以后得到苹果的概率是$\frac{p}{4}$，这是这种情况只有在第1次和第2次抛硬币都没有抛到正面(概率为$\frac{1}{2}\times\frac{1}{2}=\frac{1}{4}$)的时候才发生，而此时先手在此面临和开始相同的局面； 所以可以列出等式：$p=\frac{1}{2}+\frac{p}{4}$，解出来$p=\frac{2}{3}$]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[凸四边形面积]]></title>
    <url>%2F2020%2F07%2F21%2F%E5%87%B8%E5%9B%9B%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目描述]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[312.戳气球]]></title>
    <url>%2F2020%2F07%2F19%2F312-%E6%88%B3%E6%B0%94%E7%90%83%2F</url>
    <content type="text"><![CDATA[题目描述]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[746.使用最小花费爬楼梯]]></title>
    <url>%2F2020%2F07%2F18%2F746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[题目描述]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[97.交错字符串]]></title>
    <url>%2F2020%2F07%2F18%2F97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。 1234567示例 1:输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;输出: true示例 2:输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;输出: false 题解思路这道题动态规划其实挺难想的，但是如果想通了就感觉很简单。定义dp[i][j]代表s1的前i个元素和s2的前j个元素是否能交错组成s3的i+j个元素。如果s1的第i个元素和s3的第i+j个元素相等，那么s1的前i个元素和s2的前j个元素是否能交错组成s3的i+j个元素取决于s1的前i-1个元素和s2的前j个元素是否能交错组成s3的i+j-1个元素，也就是说当s1[i-1]==s3[i+j-1]时，dp[i][j]=dp[i-1][j]，同理可得，当s2[j-1]==s3[i+j-1]时，dp[i][j]=dp[i][j-1]，所以状态转移方程如下： dp(i,j)= \left\{\begin{matrix} dp(i-1, j),(s1[i-1]=s3[i+j-1])\\ dp(i, j-1),(s2[j-1]=s3[i+j-1])\\ false,others \end{matrix}\right.可以简化写成： dp[i][j]=(dp[i-1][j] \&\& (s1[i-1]==s3[i+j-1])) || (dp[i][j-1] \&\& (s2[j-1]==s3[i+j-1]))同时要注意一下边界值，当i=0时，拿s2和s3单独比较，如果s2[j]!=s3[j]时，就把dp[0][j+1]以及后面的都置为false，当j=0时候同理。很显然我们可以得出dp[0][0]是true。 代码123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; //定义一个二维数组，初始化为false。 auto dp = vector&lt; vector&lt;bool&gt; &gt;(s1.size()+1, vector&lt;bool&gt;(s2.size()+1, false)); int len1=s1.length(), len2=s2.length(), len3=s3.length(); if(len1+len2!=len3) return false; //dp数组初始化 dp[0][0]=true; for(int i=1;i&lt;=len1;i++)&#123; if(s1[i-1]==s3[i-1]) dp[i][0]=dp[i-1][0]; else break; &#125; for(int i=1;i&lt;=len2;i++)&#123; if(s2[i-1]==s3[i-1]) dp[0][i]=dp[0][i-1]; else break; &#125; //状态转移 for(int i=1;i&lt;=len1;i++)&#123; for(int j=1;j&lt;=len2;j++)&#123; dp[i][j]=(dp[i-1][j] &amp;&amp; (s1[i-1]==s3[i+j-1])) || (dp[i][j-1] &amp;&amp; (s2[j-1]==s3[i+j-1])); &#125; &#125; return dp[len1][len2]; &#125;&#125;; 滚动数组优化空间因为dp[i][j]仅仅依赖于dp[i-1][j]或者dp[i][j-1]，也就是dp数组只依赖于自身和上一行的值，所以可以使用滚动数组来优化空间复杂度。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; //定义一个二维数组，初始化为false。 int len1=s1.length(), len2=s2.length(), len3=s3.length(); auto dp = vector&lt;bool&gt;(len3+1, false); if(len1+len2!=len3) return false; dp[0]=true; if(len2==0) &#123; for(int i=1;i&lt;=len1;i++)&#123; if(s1[i-1]==s3[i-1]) dp[i]=dp[i-1]; else break; &#125; return dp[len1]; &#125; //dp数组初始化 for(int j=1;j&lt;=len2;j++)&#123; if(s2[j-1]==s3[j-1]) dp[j]=dp[j-1]; else break; &#125; //状态转移 for(int i=1;i&lt;=len1;i++)&#123; for(int j=0;j&lt;=len2;j++)&#123; dp[j]= dp[j] &amp;&amp; (s1[i-1]==s3[i+j-1]); if(j&gt;0) dp[j]=dp[j] || (dp[j-1] &amp;&amp; (s2[j-1]==s3[i+j-1])); &#125; &#125; return dp[len2]; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>滚动数组优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为面经]]></title>
    <url>%2F2020%2F07%2F18%2F%E5%8D%8E%E4%B8%BA%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[数据结构 链表和数组的优缺点 链表 优点： 便于插入和删除 内存利用率高，不会浪费内存 大小没有固定，扩展很灵活 缺点：不能随机查找，查找元素和修改单个元素慢 数组 优点：便于随机存取，查找快，修改快 缺点： 不方便插入和删除元素 内存空间要求高，必须有足够的连续内存空间 数组大小固定，不能动态扩展 栈和队列的区别 栈：先进后出，后进先出 队列：先进先出 二叉树的遍历算法如何实现的 递归 迭代 二叉树的深度怎么算的$log_2N$ 图和二叉树的区别 图的遍历算法怎么实现的 dfs bfs 快排怎么实现的，是否是稳定的，时间复杂度 稳定，复杂度： $nlogn$ 树的遍历方法。 前序遍历 中序遍历 后序遍历 层序遍历（要用到队列） 讲一下B-树 B-树、B+树以及B*树的原理详解 什么是完全二叉树？ 满二叉树、完全二叉树、平衡二叉树、最优二叉树 计算机网络 tcp/ip的网络分层，tcp属于哪一层 tcp协议的建立过程 tcp和udp的区别 ISO七层模型每一层分别是做什么，与TCP/IP模型有什么区别 网络拥塞的内容 介绍TCP/IP模型 TCP和IP协议 TCP三次握手，四次挥手。 ISO分层的原因，好处 操作系统 32位操作系统，8G内存。为什么实际只有4G？ 32位寻址空间只有32位，就是 $2^{32}=2^{22}K=2^{12}M=2^{2}G=4G$ 详解 每个进程为什么分配了4G内存？ 了解LINUX内核吗 C++ c++内存管理（内存分为哪些区域、指针存在什么地方、堆和栈里面存放什么） 多态的实现？ C的static 手写代码 判断链表是否有环 1到1000中数字含有的9的个数。 两个单链表怎么判断相交。 其他 介绍自己的做过的项目，自己在其中的角色，是如何去实现的 问课题 问项目 拓展开来 设计模式，用到过哪些，是怎么解耦的,别说单例]]></content>
      <categories>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[96.不同的二叉搜索树]]></title>
    <url>%2F2020%2F07%2F16%2F96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目链接96.不同的二叉搜索树 题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 1234567891011示例:输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路动态规划思路给定一个有序序列 $1…n$，为了构建一棵二叉搜索树，我们可以遍历每个数字 $i$，把该数字作为树根，将 $1…(i-1)$序列作为左子树， $(i+1)…n$序列作为右子树，然后我们可以用递归的方式来构建左子树和右子树。 于是原问题就被划分成了两个子问题，所以可以用动态规划的方法来求解，定义两个函数： $G(n):长度为n的序列能构成不同二叉搜索树的个数$ $F(i,n):以i为根，长度为n的序列能构成不同二叉搜索树的个数(1\leqslant i \leqslant n)$ 于是， $G(n)$就是我们求解需要的函数，我们可以发现，这两个函数是有关系的： G(n)=\sum_{i=1}^{n}F(i,n) \\ F(i,n)=G(i-1)\times G(n-i)所以我们可以推出： G(n)=\sum_{i=1}^{n}G(i-1)G(n-i)这样我们只要从前往后把 $G(n)$一点一点算出来就行，因为 $G(n)$的值依赖于 $G(0)···G(n-1)$ 。在这之前我们需要确定边界值，当序列长度为1（只有根）或为0（空树）时，只有一种情况，所以不难得出： G(0)=0\\ G(1)=1代码123456789101112131415class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; G(n + 1, 0); G[0] = 1; G[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; G[i] += G[j - 1] * G[i - j]; &#125; &#125; return G[n]; &#125;&#125;; 数学方法：卡特兰数思路上面已经推出了 $G(n)$的一种递推公式，其实还可以推出另一种递推公式来，这里就不去推了，直接给出来： C_{n+1}=\frac{2(2n+1)}{n+2}C_n代码12345678910class Solution &#123;public: int numTrees(int n) &#123; long long C = 1; for (int i = 0; i &lt; n; ++i) &#123; C = C * 2 * (2 * i + 1) / (i + 2); &#125; return (int)C; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[785.判断二分图]]></title>
    <url>%2F2020%2F07%2F16%2F785-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[题目链接785.判断二分图 题目描述给定一个无向图graph，当这个图为二分图时返回true。 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。 graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。 12345678910示例 1:输入: [[1,3], [0,2], [1,3], [0,2]]输出: true解释: 无向图如下:0----1| || |3----2我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。 12345678910示例 2:输入: [[1,2,3], [0,2], [0,1,3], [0,2]]输出: false解释: 无向图如下:0----1| \ || \ |3----2我们不能将节点分割成两个独立的子集。 注意: graph 的长度范围为 [1, 100]。 graph[i] 中的元素的范围为 [0, graph.length - 1]。 graph[i] 不会包含 i 或者有重复的值。 图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。 解题思路什么是二分图二分图也叫二部图。对于图中的任意两个节点u和v，如果他们之间有一条边相连，那么u和v必须属于不同的集合。并且只能有两个集合，如果两个相连的点在同一个集合，就不是二分图。 如何判断二分图判断这个图是否是二分图，我们可以对其节点进行染色操作，最后根据染色的结果来判断是否是二分图。 我们可以任选一个节点开始，将起染成红色，然后遍历与其相连的节点，把他们都染成绿色，再把和这些绿色节点相邻的点染成红色，以此类推，直到所有的节点都被染色。 如果我们染色成功，则红色节点和绿色节点分属两个集合，这个无向图就是个二分图；如果我们不能成功染色，就是说在染色过程中遇到了一个已经染色的节点，假设它是红色的，但我们现在要把它染成绿色，这就发生了矛盾，就无法继续染色了，说明这个图就不是二分图。 算法流程 任选一个节点，将其染成红色，并从该节点开始对整个无向图进行遍历； 在遍历的过程中，如果我们通过节点 u 遍历到了节点 v（即 u 和 v 在图中有一条边直接相连），那么会有两种情况： 如果 v 未被染色，那么我们将其染成与 u 不同的颜色，并对 v 直接相连的节点进行遍历； 如果 v 被染色，并且颜色与 u 相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回 False作为答案。 当遍历结束时，说明给定的无向图是二分图，返回 True 作为答案； 可以使用DFS或者BFS对无向图进行遍历。 注意题目中给定的无向图不一定保证连通，因此我们需要进行多次遍历，直到每一个节点都被染色，或确定答案为False 为止。每次遍历开始时，我们任选一个未被染色的节点，将所有与该节点直接或间接相连的节点进行染色。 代码dfs123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;private: static constexpr int UNCOLORED = 0; static constexpr int RED = 1; static constexpr int GREEN = 2; vector&lt;int&gt; color; //记录节点涂色的情况 bool flag; //记录是否是二分图public: void dfs(int node, int c, vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; color[node]=c; if(!flag) return; int nextColor=(c==RED?GREEN:RED); for(int neighbour:graph[node]) &#123; if(color[neighbour]==UNCOLORED)&#123; dfs(neighbour, nextColor, graph); &#125; else if(color[neighbour]!=nextColor)&#123; flag = false; return; &#125; &#125; &#125; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int n=graph.size(); color.assign(n,UNCOLORED);//先把图中每个点初始化为未涂色 flag = true; for(int i=0;i&lt;n;i++)&#123; if(color[i]==UNCOLORED)&#123; dfs(i, RED, graph); &#125; &#125; return flag; &#125;&#125;; bfs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;private: static constexpr int UNCOLORED = 0; static constexpr int RED = 1; static constexpr int GREEN = 2; vector&lt;int&gt; color; //记录节点涂色的情况 bool flag; //记录是否是二分图public: bool bfs(int node, int c, vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; queue&lt;int&gt;Q; Q.push(node); color[node]=c; while(!Q.empty()) &#123; int front=Q.front(); Q.pop(); int nextColor=(color[front]==RED?GREEN:RED); for(int neighbor:graph[front]) &#123; if(color[neighbor]==UNCOLORED) &#123; color[neighbor]=nextColor; Q.push(neighbor); &#125; else if(color[neighbor]!=nextColor) return false; &#125; &#125; return true; &#125; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int n=graph.size(); color.assign(n,UNCOLORED);//先把图中每个点初始化为未涂色 flag = true; for(int i=0;i&lt;n;i++)&#123; if(color[i]==UNCOLORED)&#123; flag = bfs(i, RED, graph); if(!flag) return flag; &#125; &#125; return true; &#125;&#125;; ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>二分图</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机启动的过程]]></title>
    <url>%2F2020%2F07%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[二分法边界值问题总结]]></title>
    <url>%2F2020%2F07%2F02%2F%E4%BA%8C%E5%88%86%E6%B3%95%E8%BE%B9%E7%95%8C%E5%80%BC%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[二分法边界值问题总结一、结论先说结论，二分边界值一般有两种正确的写法： 第一种写法，二分的区间左闭右开，[left, right)： 123456789101112int left=0,right=nums.size();//right取不到int mid=0;while(left&lt;right)//这里是小于号&#123; mid=left+(right-left)/2;//一般都这么写，防止left+right溢出 if(nums[mid]==target) return mid; if(nums[mid]&lt;target) left=mid+1; else right=mid;//注意&#125; 第二种写法，二分的区间左右都是闭的，[left, right]： 123456789101112int left=0,right=nums.size()-1;//right能取到int mid=0;while(left&lt;=right)//这里是小于等于&#123; mid=left+(right-left)/2; if(nums[mid]==target) return mid; if(nums[mid]&lt;target) left=mid+1; else right=mid-1;//注意&#125; 二、原理]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[minecraft常用指令]]></title>
    <url>%2F2020%2F01%2F17%2Fminecraft%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[/gamerule mobGriefing false 关闭爆炸破坏方块 /gamerule doFireTick false 关闭火势蔓延 /gamerule keepInventory true 开启死亡不掉落 /difficulty 0 调整难度，0为和平，1为简单，2为普通，3为困难 /spawnpoint [玩家] 设置玩家的出生点为脚下 /setworldspawn 设置全服玩家的出生点为脚下]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加和删除live2D模型]]></title>
    <url>%2F2020%2F01%2F17%2Fhexo%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4live2D%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[添加live2d模型]]></content>
  </entry>
  <entry>
    <title><![CDATA[postgresql入门]]></title>
    <url>%2F2019%2F10%2F12%2Fpostgresql%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[postgresql 常用指令 在命令行输入 psql -l localhost -U postgres 连接本地的数据库，用户名为postgres； 指令 功能 \l 显示所有数据库 \d 显示当前库中所有表 \d [表名] 显示该表内容 \q 断开与数据库的连接 \c - [user] 切换到用户user \c [库名] 进入该数据库 alter table 表名 add (字段 字段类型) [ default &#39;输入默认值&#39;] [null/not null] ;举例：ALTER TABLE employee ADD spbh varchar(20) NOT NULL Default 0 备份数据库：在命令行输入pg_dump -h localhost -U postgres &quot;student&quot; &gt; &quot;d:\student.sql&quot;或者pg_dump -h localhost -U postgres -d student -f &quot;d:\ student.sql&quot; -h: 服务器地址； -U: 用户名; -d: 待备份数据库； -f: 输出文件名(或者目录) -F: 备份文件输出格式 (custom, directory,tar, plain text[默认]), -s: 只转储模式, 不包括数据 数据库还原：先使用SQL语句建立Student数据库，再利用备份的.sql文件进行还原。打开cmd.exe运行程序，切换到postgresql的bin目录下面（如果已经配置环境变量，不需要切换），使用以下命令进行还原：psql -h localhost -U postgres -d &quot;student&quot; &lt; &quot;d:\student.sql&quot;或者：pg_restore -h localhost -U postgres -d &quot;student&quot; &lt; &quot;d:\student.sql&quot; 修改表中数据update [表名] set [目标字段名]=[目标值] where [该行特征]]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux服务器的screen简单使用]]></title>
    <url>%2F2019%2F10%2F09%2Flinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84screen%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[远程连接服务器时，当你断开ssh窗口，当前的操作也会终止，这时候需要用到screen来保持当前窗口在后台运行。 Screen 常用指令 screen -S yourname -&gt; 新建一个叫yourname的sessionscreen -ls -&gt; 列出当前所有的sessionscreen -r yourname -&gt; 回到yourname这个sessionscreen -d yourname -&gt; 远程detach某个sessionscreen -X -S yourname -&gt; 关闭这个session Screen 常用操作 Ctrl-a d -&gt; detach，暂时离开当前session 关于Screen详细解析点此]]></content>
  </entry>
  <entry>
    <title><![CDATA[MNIST数据集入门]]></title>
    <url>%2F2019%2F07%2F14%2FMNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[引言相信很多深度学习的初学者都会触碰mnist数据集，tensorflow官方教程里也将这个数据集当做示例来供新手入门练手，但是其并没有详细讲解mnist的内部构造，下面就来介绍一下 简介MNIST是一个入门级的计算机视觉数据集，它包含各种手写数字图片]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>mnist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft开服教程]]></title>
    <url>%2F2019%2F07%2F02%2FMinecraft%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[几点说明 本篇为我的世界服务端搭建的教程，简单来说就是教你如何开服，与小伙伴在同一个世界里玩耍。 当然，如果你的服务端搭建在远程vps上就可以远程联机，如果服务端只是在你本地运行的话那只有和你同属局域网的人才能联机。 Spigot 纯净服务端搭建我本人并不推荐官方的服务端，不能安装插件，优化也不怎么样，可以说，Spigot/Bukkit 是当前最稳定高效的纯净服务端了，并且其有强大的社区，各种各样的插件，可玩性是相当的高。下面就来说说该如何搭建 spigot 1.12.2 服务端。 首先要下载 spigot 1.12.2 服务端核心。这个服务端核心在官网是找不到的，你只能下载到构建工具，点此直接下载服务端核心 百度网盘提取码:cw2g。 新建一个文件夹，就取名叫 server 吧，然后把刚才下载的spigot-1.12.2.jar文件丢进去。 在 server 文件夹内新建一个文件，将其改名为 run.bat，用编辑器打开，复制这一段代码进去并保存： 12Java -jar -Xms1G -Xmx2G spigot-1.12.2.jar noguiPAUSE 其实这是个windows批处理文件，之后你双击这个文件就相当于在命令行输入了这些语句，这样开服就方便些，不需要每次都输命令那么麻烦。简单解释一下这些参数的含义吧： Java -jar 是指用java运行这个jar包，也就是后面那个spigot-1.12.2，就是服务端的核心； -Xms1G 运行服务器的最小内存，这里给了1G； -Xmx2G 运行服务器的最大内存，这里给了2G，当然你可以根据实际情况修改； nogui 指不启用gui，因为你服务端本来就没有gui； PAUSE 这行让你在关闭服务器之后不会立刻关闭命令行。 双击 run.bat 文件，会自动跳出了命令行，然后报错，这时关闭命令行，你会发现 server 文件夹里多出来一些东西，这时打开 eula.txt ,将 eula=false 改成 eula=true ，表示你同意mojang的eula协定。 再次双击 run.bat 文件，等待它生成一些配置文件和加载世界结束后，服务器就能正常运行了。 但这还没有结束，你会发现如果不用正版账号根本进不去服务器。所以要用编辑器打开 server.properties ，找到 online-mode=true 这一行，将其改为 online-mode=false ，意思就是关闭在线模式，这样用离线模式就能登录服务器了。 现在服务器已经搭建成功，接下来你要知道你的服务器地址，打开命令行，输入 ipconfig ，回车，查看你的ipv4地址，复制，然后打开游戏客户端，进入多人游戏，点击 添加服务器 按钮，在服务器地址框里粘贴刚才复制的ip，在后面加上端口号25565，中间要加上冒号”:”，这里要注意一定是英文的冒号，如果是中文冒号客户端就找不到服务器，之后点击 完成 按钮。 一切就绪，现在点击加入服务器按钮就可以进入游戏，同时你可以将服务器地址和端口号告诉别人和你一起联机，前提是要在一个内网下，不过一般高校的校园网内都是能联机的。]]></content>
      <categories>
        <category>Minecraft</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spigot 1.12.2 Tutorial 01 Spigot的前世今生]]></title>
    <url>%2F2019%2F06%2F29%2FSpigot-1-12-2-Tutorial-01-Spigot%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%2F</url>
    <content type="text"></content>
      <categories>
        <category>Minecraft</category>
        <category>Spigot</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Plugin</tag>
        <tag>Spigot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft 1.12.2 Mod Tutorial 02 你的第一个mod]]></title>
    <url>%2F2019%2F06%2F27%2FMinecraft-1-12-2-Mod-Tutorial-02-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAmod%2F</url>
    <content type="text"><![CDATA[一、解读Example Mod二、构建并发布你的mod]]></content>
      <categories>
        <category>Minecraft</category>
        <category>Forge</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Mod</tag>
        <tag>Forge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft 1.12.2 Mod Tutorial 01 搭建开发环境]]></title>
    <url>%2F2019%2F06%2F26%2FMinecraft-1-12-2-Mod-Tutorial-01-%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一、安装Java既然要写mod，那么java必不可少，首先我们就来安装jdk (java development kit)。jdk可以去官网下载。下载完毕后一路下一步即可安装。 二、安装IntelliJ IDEA这里更推荐用IDEA来进行mod开发，原因就是非常好用并且IDEA有关于mc开发的插件。同样给出下载链接Intellij IDEA 官网下载。社区版即可，如果有教育邮箱可以免费使用付费版本，下载后按照流程安装即可。 三、搭建mod开发环境1.下载mdkmdk可以直接去Forge官网下载推荐的稳定版本Mdk 1.12.2-14.23.5.2768 2.解压mdk将下载好的Mdk解压到你的工程目录，然后我们用编辑器打开build.gradle文件，在最下面加上下面一段代码，目的是将构建的编码改为UTF-8。123tasks.withType(JavaCompile)&#123; options.encoding = "UTF-8"&#125; 其他部分改不改都无所谓，不过你也可以自己研究研究这个文件的其他部分。 3.构建环境在当前目录打开命令行，输入这个命令1gradlew setupDecompWorkspace idea 接下来就是漫长的等待，当出现 build successful 就是构建成功了。 4.在IDEA中运行项目]]></content>
      <categories>
        <category>Minecraft</category>
        <category>Forge</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Mod</tag>
        <tag>Forge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java命名规范]]></title>
    <url>%2F2018%2F08%2F01%2FJava%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[类名命名规范 类名应该采用大写驼峰式（Upper Camel Case），大写驼峰式指的是每个单词只有首字母大写，然后把它们直接拼合起来，比如 immersiveEngineering 等。 对于缩写单词，所有字母全部大写或者只有首字母大写往往都可以，比如FMLTutor和FmlTutor都是可以的。 方法和字段的命名惯例 小写驼峰式（Lower Camel Case），小写驼峰式指的是只有第一个单词全部小写，第二个开始的单词的所有字母中只有首字母大写，然后把它们直接拼合起来，比如getRegistryName方法等。 全大写加下画线（Upper Snake Case），即将所有字母大写，然后单词之间使用下画线分隔。 在通常情况下，Java规定，只有同时被 final和 static两个修饰符修饰的字段，即不可变静态字段，才应该使用全大写加下画线的命名风格命名，而在其他情况下的方法和字段都应该使用小写驼峰命名。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印全排列]]></title>
    <url>%2F2018%2F07%2F21%2F%E6%89%93%E5%8D%B0%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入n，代表有n个数，然后输入这n个数，要求打印出这n个数的全排列。 思路全排列问题就是递归和回溯的思想。这里有两种思路： 不改变原数组所谓不改变原数组，就是从原数组中n个数中挑选n个数排起来。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000;int a[maxn];int n;int out[maxn];int vis[maxn];//n个数全排列，排到了第m个void dfs(int m)&#123; if(m==n+1)//选到了第n+1个，说明选完了 &#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;out[i]&lt;&lt;' '; cout&lt;&lt;endl; return; &#125; //一个一个数看是否用过 for(int i=1;i&lt;=n;i++) &#123; if(!vis[i]) &#123; out[m]=a[i];//第m个数是a[i] vis[i]=1;//标记一下选过 dfs(m+1);//排第m+1个数 vis[i]=0;//回溯 &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); dfs(1);//从第一个数开始排 &#125; return 0;&#125; 改变原数组在原数组的基础上调换顺序，生成全排列序列，每次选一个数和后面的数依次交换，形成全排列。注意这种方法无法字典序输出全排列。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000;int a[maxn];int n;//n个数全排列，排到了第m个void dfs(int m)&#123; if(m==n) &#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;' '; cout&lt;&lt;endl; return; &#125; //从当前数开始和后面的数交换 for(int i=m;i&lt;=n;i++) &#123; swap(a[m], a[i]); dfs(m+1); swap(a[m], a[i]); &#125;&#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); dfs(1);//从第一个数开始排 &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印组合数]]></title>
    <url>%2F2018%2F07%2F21%2F%E6%89%93%E5%8D%B0%E7%BB%84%E5%90%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述首先给你一个 n (n&gt;0) 和 k (0&lt;k&lt;n)。 然后给你 n个没有重复的整数，数字间用空格分开。你需要输出这些数字的$C_n^k$种组合。 组合中的元素用空格分开，末尾无多余空格。组合内部的数字由小到大排列。不同的组合由小到大排列。具体见案例。 样例输入 5 2 1 2 3 4 5 样例输出 1 21 31 41 52 32 42 53 43 54 5 题解和全排列比较像，也是递归和回溯。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000;int a[maxn];int n,k;int out[maxn];int vis[maxn];//n个数选k个数，选到了第m个，并且上一个是第lastStartIndexvoid dfs(int m, int lastStartIndex)&#123; if(m==k+1)//选到了第k+1个，说明选完了 &#123; for(int i=1;i&lt;=k;i++) cout&lt;&lt;out[i]&lt;&lt;' '; cout&lt;&lt;endl; return; &#125; //因为是组合问题，不能重复，所以从上次选的位置的下一个开始 for(int i=lastStartIndex;i&lt;=n;i++) &#123; if(!vis[i]) &#123; out[m]=a[i];//第m个数是a[i] vis[i]=1;//标记一下选过 dfs(m+1, i+1);//从当前下一个位置开始选第m+1个数 vis[i]=0;//回溯 &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;k) &#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1); dfs(1, 1);//从第一个数开始选第一个数 &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memset的用法浅谈]]></title>
    <url>%2F2018%2F07%2F17%2Fmemset%E7%9A%84%E7%94%A8%E6%B3%95%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[简介memset()是用来给一块空间批量赋值的函数，经常用来给数组初始化为0或者-1，但是不能初始化为1，为什么下面会讲到。 描述C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 头文件#include&lt;cstring&gt; 参数 str — 指向要填充的内存块。 c — 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。 n — 要被设置为该值的字节数。 用法123456789101112int a[100];//把一个数组赋值为全0memset(a, 0, sizeof(a));//把一个数组赋值为全-1memset(a, -1, sizeof(a));//注意这样并不能把一个数组赋值为全1memset(a, 1, sizeof(a));//sizeof(a)是获取a的字节数，而不是元素个数，如果是int数组就是4:1的关系。 注意要注意 memset()这个函数是按字节初始化的，比如这里的memset(a, 1, sizeof(a));他是把整数1(0x00000001)的最后一个字节赋值给a这个数组的所有字节，所以a数组的每个元素的值变成了0x01010101，这个数的十进制形式显然不是1。 那么为什么-1和0就可以正常赋值呢，那是因为-1(0xffffffff)和0(0x00000000)的每个字节都是一样的，所以换句话说，只要一个整数每个字节都是一样的，就可以用memset()来批量赋值，比如0x3f3f3f3f、0x7f7f7f7f等。]]></content>
      <categories>
        <category>编程语言</category>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>memset</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
