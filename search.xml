<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[华为面经]]></title>
    <url>%2F2020%2F07%2F18%2F%E5%8D%8E%E4%B8%BA%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[数据结构 链表和数组的优缺点 链表 优点： 便于插入和删除 内存利用率高，不会浪费内存 大小没有固定，扩展很灵活 缺点：不能随机查找，查找元素和修改单个元素慢 数组 优点：便于随机存取，查找快，修改快 缺点： 不方便插入和删除元素 内存空间要求高，必须有足够的连续内存空间 数组大小固定，不能动态扩展 栈和队列的区别 栈：先进后出，后进先出 队列：先进先出 二叉树的遍历算法如何实现的 递归 迭代 二叉树的深度怎么算的 $log_2N$ 图和二叉树的区别 图的遍历算法怎么实现的 dfs bfs 快排怎么实现的，是否是稳定的，时间复杂度 稳定，复杂度： $nlogn$ 树的遍历方法。 前序遍历 中序遍历 后序遍历 层序遍历（要用到队列） 讲一下B-树 B-树、B+树以及B*树的原理详解 什么是完全二叉树？ 满二叉树、完全二叉树、平衡二叉树、最优二叉树 计算机网络 tcp/ip的网络分层，tcp属于哪一层 tcp协议的建立过程 tcp和udp的区别 ISO七层模型每一层分别是做什么，与TCP/IP模型有什么区别 网络拥塞的内容 介绍TCP/IP模型 TCP和IP协议 TCP三次握手，四次挥手。 ISO分层的原因，好处 操作系统 32位操作系统，8G内存。为什么实际只有4G？ 32位寻址空间只有32位，就是 $2^{32}=2^{22}K=2^{12}M=2^{2}G=4G$ 详解 每个进程为什么分配了4G内存？ 了解LINUX内核吗 C++ c++内存管理（内存分为哪些区域、指针存在什么地方、堆和栈里面存放什么） 多态的实现？ C的static 手写代码 判断链表是否有环 1到1000中数字含有的9的个数。 两个单链表怎么判断相交。 其他 介绍自己的做过的项目，自己在其中的角色，是如何去实现的 问课题 问项目 拓展开来 设计模式，用到过哪些，是怎么解耦的,别说单例]]></content>
      <categories>
        <category>计算机基础知识</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[96.不同的二叉搜索树]]></title>
    <url>%2F2020%2F07%2F16%2F96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目链接96.不同的二叉搜索树 题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 1234567891011示例:输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路动态规划思路给定一个有序序列 $1…n$，为了构建一棵二叉搜索树，我们可以遍历每个数字 $i$，把该数字作为树根，将 $1…(i-1)$序列作为左子树， $(i+1)…n$序列作为右子树，然后我们可以用递归的方式来构建左子树和右子树。 于是原问题就被划分成了两个子问题，所以可以用动态规划的方法来求解，定义两个函数： $G(n):长度为n的序列能构成不同二叉搜索树的个数$ $F(i,n):以i为根，长度为n的序列能构成不同二叉搜索树的个数(1\leqslant i \leqslant n)$ 于是， $G(n)$就是我们求解需要的函数，我们可以发现，这两个函数是有关系的： G(n)=\sum_{i=1}^{n}F(i,n) \\ F(i,n)=G(i-1)\times G(n-i)所以我们可以推出： G(n)=\sum_{i=1}^{n}G(i-1)G(n-i)这样我们只要从前往后把 $G(n)$一点一点算出来就行，因为 $G(n)$的值依赖于 $G(0)···G(n-1)$ 。在这之前我们需要确定边界值，当序列长度为1（只有根）或为0（空树）时，只有一种情况，所以不难得出： G(0)=0\\ G(1)=1代码123456789101112131415class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; G(n + 1, 0); G[0] = 1; G[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; G[i] += G[j - 1] * G[i - j]; &#125; &#125; return G[n]; &#125;&#125;; 数学方法：卡特兰数思路上面已经推出了 $G(n)$的一种递推公式，其实还可以推出另一种递推公式来，这里就不去推了，直接给出来： C_{n+1}=\frac{2(2n+1)}{n+2}C_n代码12345678910class Solution &#123;public: int numTrees(int n) &#123; long long C = 1; for (int i = 0; i &lt; n; ++i) &#123; C = C * 2 * (2 * i + 1) / (i + 2); &#125; return (int)C; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[785.判断二分图]]></title>
    <url>%2F2020%2F07%2F16%2F785-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[题目链接785.判断二分图 题目描述给定一个无向图graph，当这个图为二分图时返回true。 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。 graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。 12345678910示例 1:输入: [[1,3], [0,2], [1,3], [0,2]]输出: true解释: 无向图如下:0----1| || |3----2我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。 12345678910示例 2:输入: [[1,2,3], [0,2], [0,1,3], [0,2]]输出: false解释: 无向图如下:0----1| \ || \ |3----2我们不能将节点分割成两个独立的子集。 注意: graph 的长度范围为 [1, 100]。 graph[i] 中的元素的范围为 [0, graph.length - 1]。 graph[i] 不会包含 i 或者有重复的值。 图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。 解题思路什么是二分图二分图也叫二部图。对于图中的任意两个节点u和v，如果他们之间有一条边相连，那么u和v必须属于不同的集合。并且只能有两个集合，如果两个相连的点在同一个集合，就不是二分图。 如何判断二分图判断这个图是否是二分图，我们可以对其节点进行染色操作，最后根据染色的结果来判断是否是二分图。 我们可以任选一个节点开始，将起染成红色，然后遍历与其相连的节点，把他们都染成绿色，再把和这些绿色节点相邻的点染成红色，以此类推，直到所有的节点都被染色。 如果我们染色成功，则红色节点和绿色节点分属两个集合，这个无向图就是个二分图；如果我们不能成功染色，就是说在染色过程中遇到了一个已经染色的节点，假设它是红色的，但我们现在要把它染成绿色，这就发生了矛盾，就无法继续染色了，说明这个图就不是二分图。 算法流程 任选一个节点，将其染成红色，并从该节点开始对整个无向图进行遍历； 在遍历的过程中，如果我们通过节点 u 遍历到了节点 v（即 u 和 v 在图中有一条边直接相连），那么会有两种情况： 如果 v 未被染色，那么我们将其染成与 u 不同的颜色，并对 v 直接相连的节点进行遍历； 如果 v 被染色，并且颜色与 u 相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回 False作为答案。 当遍历结束时，说明给定的无向图是二分图，返回 True 作为答案； 可以使用DFS或者BFS对无向图进行遍历。 注意题目中给定的无向图不一定保证连通，因此我们需要进行多次遍历，直到每一个节点都被染色，或确定答案为False 为止。每次遍历开始时，我们任选一个未被染色的节点，将所有与该节点直接或间接相连的节点进行染色。 代码dfs123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;private: static constexpr int UNCOLORED = 0; static constexpr int RED = 1; static constexpr int GREEN = 2; vector&lt;int&gt; color; //记录节点涂色的情况 bool flag; //记录是否是二分图public: void dfs(int node, int c, vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; color[node]=c; if(!flag) return; int nextColor=(c==RED?GREEN:RED); for(int neighbour:graph[node]) &#123; if(color[neighbour]==UNCOLORED)&#123; dfs(neighbour, nextColor, graph); &#125; else if(color[neighbour]!=nextColor)&#123; flag = false; return; &#125; &#125; &#125; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int n=graph.size(); color.assign(n,UNCOLORED);//先把图中每个点初始化为未涂色 flag = true; for(int i=0;i&lt;n;i++)&#123; if(color[i]==UNCOLORED)&#123; dfs(i, RED, graph); &#125; &#125; return flag; &#125;&#125;; bfs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;private: static constexpr int UNCOLORED = 0; static constexpr int RED = 1; static constexpr int GREEN = 2; vector&lt;int&gt; color; //记录节点涂色的情况 bool flag; //记录是否是二分图public: bool bfs(int node, int c, vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; queue&lt;int&gt;Q; Q.push(node); color[node]=c; while(!Q.empty()) &#123; int front=Q.front(); Q.pop(); int nextColor=(color[front]==RED?GREEN:RED); for(int neighbor:graph[front]) &#123; if(color[neighbor]==UNCOLORED) &#123; color[neighbor]=nextColor; Q.push(neighbor); &#125; else if(color[neighbor]!=nextColor) return false; &#125; &#125; return true; &#125; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int n=graph.size(); color.assign(n,UNCOLORED);//先把图中每个点初始化为未涂色 flag = true; for(int i=0;i&lt;n;i++)&#123; if(color[i]==UNCOLORED)&#123; flag = bfs(i, RED, graph); if(!flag) return flag; &#125; &#125; return true; &#125;&#125;; ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机启动的过程]]></title>
    <url>%2F2020%2F07%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[二分法边界值问题总结]]></title>
    <url>%2F2020%2F07%2F02%2F%E4%BA%8C%E5%88%86%E6%B3%95%E8%BE%B9%E7%95%8C%E5%80%BC%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[二分法边界值问题总结一、结论先说结论，二分边界值一般有两种正确的写法： 第一种写法，二分的区间左闭右开，[left, right)： 123456789101112int left=0,right=nums.size();//right取不到int mid=0;while(left&lt;right)//这里是小于号&#123; mid=left+(right-left)/2;//一般都这么写，防止left+right溢出 if(nums[mid]==target) return mid; if(nums[mid]&lt;target) left=mid+1; else right=mid;//注意&#125; 第二种写法，二分的区间左右都是闭的，[left, right]： 123456789101112int left=0,right=nums.size()-1;//right能取到int mid=0;while(left&lt;=right)//这里是小于等于&#123; mid=left+(right-left)/2; if(nums[mid]==target) return mid; if(nums[mid]&lt;target) left=mid+1; else right=mid-1;//注意&#125; 二、原理]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[minecraft常用指令]]></title>
    <url>%2F2020%2F01%2F17%2Fminecraft%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[/gamerule mobGriefing false 关闭爆炸破坏方块 /gamerule doFireTick false 关闭火势蔓延 /gamerule keepInventory true 开启死亡不掉落 /difficulty 0 调整难度，0为和平，1为简单，2为普通，3为困难 /spawnpoint [玩家] 设置玩家的出生点为脚下 /setworldspawn 设置全服玩家的出生点为脚下]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加和删除live2D模型]]></title>
    <url>%2F2020%2F01%2F17%2Fhexo%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4live2D%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[添加live2d模型]]></content>
  </entry>
  <entry>
    <title><![CDATA[postgresql入门]]></title>
    <url>%2F2019%2F10%2F12%2Fpostgresql%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[postgresql 常用指令 在命令行输入 psql -l localhost -U postgres 连接本地的数据库，用户名为postgres； 指令 功能 \l 显示所有数据库 \d 显示当前库中所有表 \d [表名] 显示该表内容 \q 断开与数据库的连接 \c - [user] 切换到用户user \c [库名] 进入该数据库 alter table 表名 add (字段 字段类型) [ default &#39;输入默认值&#39;] [null/not null] ;举例：ALTER TABLE employee ADD spbh varchar(20) NOT NULL Default 0 备份数据库：在命令行输入pg_dump -h localhost -U postgres &quot;student&quot; &gt; &quot;d:\student.sql&quot;或者pg_dump -h localhost -U postgres -d student -f &quot;d:\ student.sql&quot; -h: 服务器地址； -U: 用户名; -d: 待备份数据库； -f: 输出文件名(或者目录) -F: 备份文件输出格式 (custom, directory,tar, plain text[默认]), -s: 只转储模式, 不包括数据 数据库还原：先使用SQL语句建立Student数据库，再利用备份的.sql文件进行还原。打开cmd.exe运行程序，切换到postgresql的bin目录下面（如果已经配置环境变量，不需要切换），使用以下命令进行还原：psql -h localhost -U postgres -d &quot;student&quot; &lt; &quot;d:\student.sql&quot;或者：pg_restore -h localhost -U postgres -d &quot;student&quot; &lt; &quot;d:\student.sql&quot; 修改表中数据update [表名] set [目标字段名]=[目标值] where [该行特征]]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux服务器的screen简单使用]]></title>
    <url>%2F2019%2F10%2F09%2Flinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84screen%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[远程连接服务器时，当你断开ssh窗口，当前的操作也会终止，这时候需要用到screen来保持当前窗口在后台运行。 Screen 常用指令 screen -S yourname -&gt; 新建一个叫yourname的sessionscreen -ls -&gt; 列出当前所有的sessionscreen -r yourname -&gt; 回到yourname这个sessionscreen -d yourname -&gt; 远程detach某个sessionscreen -X -S yourname -&gt; 关闭这个session Screen 常用操作 Ctrl-a d -&gt; detach，暂时离开当前session 关于Screen详细解析点此]]></content>
  </entry>
  <entry>
    <title><![CDATA[MNIST数据集入门]]></title>
    <url>%2F2019%2F07%2F14%2FMNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[引言相信很多深度学习的初学者都会触碰mnist数据集，tensorflow官方教程里也将这个数据集当做示例来供新手入门练手，但是其并没有详细讲解mnist的内部构造，下面就来介绍一下 简介MNIST是一个入门级的计算机视觉数据集，它包含各种手写数字图片]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>mnist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft开服教程]]></title>
    <url>%2F2019%2F07%2F02%2FMinecraft%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[几点说明 本篇为我的世界服务端搭建的教程，简单来说就是教你如何开服，与小伙伴在同一个世界里玩耍。 当然，如果你的服务端搭建在远程vps上就可以远程联机，如果服务端只是在你本地运行的话那只有和你同属局域网的人才能联机。 Spigot 纯净服务端搭建我本人并不推荐官方的服务端，不能安装插件，优化也不怎么样，可以说，Spigot/Bukkit 是当前最稳定高效的纯净服务端了，并且其有强大的社区，各种各样的插件，可玩性是相当的高。下面就来说说该如何搭建 spigot 1.12.2 服务端。 首先要下载 spigot 1.12.2 服务端核心。这个服务端核心在官网是找不到的，你只能下载到构建工具，点此直接下载服务端核心 百度网盘提取码:cw2g。 新建一个文件夹，就取名叫 server 吧，然后把刚才下载的spigot-1.12.2.jar文件丢进去。 在 server 文件夹内新建一个文件，将其改名为 run.bat，用编辑器打开，复制这一段代码进去并保存： 12Java -jar -Xms1G -Xmx2G spigot-1.12.2.jar noguiPAUSE 其实这是个windows批处理文件，之后你双击这个文件就相当于在命令行输入了这些语句，这样开服就方便些，不需要每次都输命令那么麻烦。简单解释一下这些参数的含义吧： Java -jar 是指用java运行这个jar包，也就是后面那个spigot-1.12.2，就是服务端的核心； -Xms1G 运行服务器的最小内存，这里给了1G； -Xmx2G 运行服务器的最大内存，这里给了2G，当然你可以根据实际情况修改； nogui 指不启用gui，因为你服务端本来就没有gui； PAUSE 这行让你在关闭服务器之后不会立刻关闭命令行。 双击 run.bat 文件，会自动跳出了命令行，然后报错，这时关闭命令行，你会发现 server 文件夹里多出来一些东西，这时打开 eula.txt ,将 eula=false 改成 eula=true ，表示你同意mojang的eula协定。 再次双击 run.bat 文件，等待它生成一些配置文件和加载世界结束后，服务器就能正常运行了。 但这还没有结束，你会发现如果不用正版账号根本进不去服务器。所以要用编辑器打开 server.properties ，找到 online-mode=true 这一行，将其改为 online-mode=false ，意思就是关闭在线模式，这样用离线模式就能登录服务器了。 现在服务器已经搭建成功，接下来你要知道你的服务器地址，打开命令行，输入 ipconfig ，回车，查看你的ipv4地址，复制，然后打开游戏客户端，进入多人游戏，点击 添加服务器 按钮，在服务器地址框里粘贴刚才复制的ip，在后面加上端口号25565，中间要加上冒号”:”，这里要注意一定是英文的冒号，如果是中文冒号客户端就找不到服务器，之后点击 完成 按钮。 一切就绪，现在点击加入服务器按钮就可以进入游戏，同时你可以将服务器地址和端口号告诉别人和你一起联机，前提是要在一个内网下，不过一般高校的校园网内都是能联机的。]]></content>
      <categories>
        <category>Minecraft</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spigot 1.12.2 Tutorial 01 Spigot的前世今生]]></title>
    <url>%2F2019%2F06%2F29%2FSpigot-1-12-2-Tutorial-01-Spigot%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%2F</url>
    <content type="text"></content>
      <categories>
        <category>Minecraft</category>
        <category>Spigot</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Plugin</tag>
        <tag>Spigot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft 1.12.2 Mod Tutorial 02 你的第一个mod]]></title>
    <url>%2F2019%2F06%2F27%2FMinecraft-1-12-2-Mod-Tutorial-02-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAmod%2F</url>
    <content type="text"><![CDATA[一、解读Example Mod二、构建并发布你的mod]]></content>
      <categories>
        <category>Minecraft</category>
        <category>Forge</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Mod</tag>
        <tag>Forge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minecraft 1.12.2 Mod Tutorial 01 搭建开发环境]]></title>
    <url>%2F2019%2F06%2F26%2FMinecraft-1-12-2-Mod-Tutorial-01-%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一、安装Java既然要写mod，那么java必不可少，首先我们就来安装jdk (java development kit)。jdk可以去官网下载。下载完毕后一路下一步即可安装。 二、安装IntelliJ IDEA这里更推荐用IDEA来进行mod开发，原因就是非常好用并且IDEA有关于mc开发的插件。同样给出下载链接Intellij IDEA 官网下载。社区版即可，如果有教育邮箱可以免费使用付费版本，下载后按照流程安装即可。 三、搭建mod开发环境1.下载mdkmdk可以直接去Forge官网下载推荐的稳定版本Mdk 1.12.2-14.23.5.2768 2.解压mdk将下载好的Mdk解压到你的工程目录，然后我们用编辑器打开build.gradle文件，在最下面加上下面一段代码，目的是将构建的编码改为UTF-8。123tasks.withType(JavaCompile)&#123; options.encoding = "UTF-8"&#125; 其他部分改不改都无所谓，不过你也可以自己研究研究这个文件的其他部分。 3.构建环境在当前目录打开命令行，输入这个命令1gradlew setupDecompWorkspace idea 接下来就是漫长的等待，当出现 build successful 就是构建成功了。 4.在IDEA中运行项目]]></content>
      <categories>
        <category>Minecraft</category>
        <category>Forge</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Mod</tag>
        <tag>Forge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memset的用法浅谈]]></title>
    <url>%2F2018%2F07%2F17%2Fmemset%E7%9A%84%E7%94%A8%E6%B3%95%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[简介memset()是用来给一块空间批量赋值的函数，经常用来给数组初始化为0或者-1，但是不能初始化为1，为什么下面会讲到。 描述C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 头文件#include&lt;cstring&gt; 参数 str — 指向要填充的内存块。 c — 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。 n — 要被设置为该值的字节数。 用法123456789101112int a[100];//把一个数组赋值为全0memset(a, 0, sizeof(a));//把一个数组赋值为全-1memset(a, -1, sizeof(a));//注意这样并不能把一个数组赋值为全1memset(a, 1, sizeof(a));//sizeof(a)是获取a的字节数，而不是元素个数，如果是int数组就是4:1的关系。 注意要注意 memset()这个函数是按字节初始化的，比如这里的memset(a, 1, sizeof(a));他是把整数1(0x00000001)的最后一个字节赋值给a这个数组的所有字节，所以a数组的每个元素的值变成了0x01010101，这个数的十进制形式显然不是1。 那么为什么-1和0就可以正常赋值呢，那是因为-1(0xffffffff)和0(0x00000000)的每个字节都是一样的，所以换句话说，只要一个整数每个字节都是一样的，就可以用memset()来批量赋值，比如0x3f3f3f3f、0x7f7f7f7f等。]]></content>
      <categories>
        <category>编程语言</category>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>memset</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
